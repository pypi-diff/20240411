# Comparing `tmp/capsule_manager_sdk-0.1.3b0-cp38-cp38-manylinux_2_27_x86_64.manylinux_2_31_x86_64.whl.zip` & `tmp/capsule_manager_sdk-0.2.0.dev20240411-py3-none-manylinux2014_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,35 +1,22 @@
-Zip file size: 6701219 bytes, number of entries: 33
-drwxr-xr-x  2.0 unx        0 b- stor 24-Mar-13 03:21 cli/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Mar-13 03:21 sdc/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Mar-13 03:21 capsule_manager_sdk-0.1.3b0.dist-info/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Mar-13 03:21 capsule_manager_sdk.libs/
--rw-r--r--  2.0 unx      581 b- defN 24-Mar-13 03:21 cli/__init__.py
--rw-r--r--  2.0 unx     8545 b- defN 24-Mar-13 03:21 cli/cms.py
--rw-r--r--  2.0 unx     7601 b- defN 24-Mar-13 03:21 cli/cms_config.py
--rw-r--r--  2.0 unx     9192 b- defN 24-Mar-13 03:21 cli/cms_util.py
-drwxr-xr-x  2.0 unx        0 b- stor 24-Mar-13 03:21 sdc/crypto/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Mar-13 03:21 sdc/lib/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Mar-13 03:21 sdc/ual/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Mar-13 03:21 sdc/util/
--rw-r--r--  2.0 unx      581 b- defN 24-Mar-13 03:21 sdc/__init__.py
--rw-r--r--  2.0 unx    27821 b- defN 24-Mar-13 03:21 sdc/capsule_manager_frame.py
--rw-r--r--  2.0 unx     1138 b- defN 24-Mar-13 03:21 sdc/error.py
--rw-r--r--  2.0 unx      581 b- defN 24-Mar-13 03:21 sdc/crypto/__init__.py
--rw-r--r--  2.0 unx     7370 b- defN 24-Mar-13 03:21 sdc/crypto/asymm.py
--rw-r--r--  2.0 unx     2588 b- defN 24-Mar-13 03:21 sdc/crypto/symm.py
--rw-r--r--  2.0 unx 10537232 b- defN 24-Mar-13 03:21 sdc/lib/libgeneration.cpython-38-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx  9046552 b- defN 24-Mar-13 03:21 sdc/lib/libverification.cpython-38-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx      581 b- defN 24-Mar-13 03:21 sdc/ual/__init__.py
--rw-r--r--  2.0 unx      634 b- defN 24-Mar-13 03:21 sdc/ual/constants.py
--rw-r--r--  2.0 unx     3616 b- defN 24-Mar-13 03:21 sdc/ual/ual.py
--rw-r--r--  2.0 unx      581 b- defN 24-Mar-13 03:21 sdc/util/__init__.py
--rw-r--r--  2.0 unx      843 b- defN 24-Mar-13 03:21 sdc/util/constants.py
--rw-r--r--  2.0 unx     7951 b- defN 24-Mar-13 03:21 sdc/util/crypto.py
--rw-r--r--  2.0 unx      973 b- defN 24-Mar-13 03:21 sdc/util/file.py
--rw-r--r--  2.0 unx     2692 b- defN 24-Mar-13 03:21 sdc/util/tool.py
--rw-r--r--  2.0 unx      666 b- defN 24-Mar-13 03:21 capsule_manager_sdk-0.1.3b0.dist-info/METADATA
--rw-r--r--  2.0 unx      149 b- defN 24-Mar-13 03:21 capsule_manager_sdk-0.1.3b0.dist-info/WHEEL
--rw-r--r--  2.0 unx      108 b- defN 24-Mar-13 03:21 capsule_manager_sdk-0.1.3b0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       54 b- defN 24-Mar-13 03:21 capsule_manager_sdk-0.1.3b0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2050 b- defN 24-Mar-13 03:21 capsule_manager_sdk-0.1.3b0.dist-info/RECORD
-33 files, 19670680 bytes uncompressed, 6697157 bytes compressed:  66.0%
+Zip file size: 22711 bytes, number of entries: 20
+-rw-r--r--  2.0 unx      581 b- defN 24-Apr-11 03:02 cli/__init__.py
+-rw-r--r--  2.0 unx     8287 b- defN 24-Apr-11 03:02 cli/cms.py
+-rw-r--r--  2.0 unx     7293 b- defN 24-Apr-11 03:02 cli/cms_config.py
+-rw-r--r--  2.0 unx     9495 b- defN 24-Apr-11 03:02 cli/cms_util.py
+-rw-r--r--  2.0 unx      581 b- defN 24-Apr-11 03:02 sdc/__init__.py
+-rw-r--r--  2.0 unx    23631 b- defN 24-Apr-11 03:02 sdc/capsule_manager_frame.py
+-rw-r--r--  2.0 unx     1138 b- defN 24-Apr-11 03:02 sdc/error.py
+-rw-r--r--  2.0 unx      581 b- defN 24-Apr-11 03:02 sdc/crypto/__init__.py
+-rw-r--r--  2.0 unx     7370 b- defN 24-Apr-11 03:02 sdc/crypto/asymm.py
+-rw-r--r--  2.0 unx     2589 b- defN 24-Apr-11 03:02 sdc/crypto/symm.py
+-rw-r--r--  2.0 unx      581 b- defN 24-Apr-11 03:02 sdc/util/__init__.py
+-rw-r--r--  2.0 unx      843 b- defN 24-Apr-11 03:02 sdc/util/constants.py
+-rw-r--r--  2.0 unx     7909 b- defN 24-Apr-11 03:02 sdc/util/crypto.py
+-rw-r--r--  2.0 unx     1183 b- defN 24-Apr-11 03:02 sdc/util/file.py
+-rw-r--r--  2.0 unx     2687 b- defN 24-Apr-11 03:02 sdc/util/tool.py
+-rw-r--r--  2.0 unx      676 b- defN 24-Apr-11 03:03 capsule_manager_sdk-0.2.0.dev20240411.dist-info/METADATA
+-rw-r--r--  2.0 unx      109 b- defN 24-Apr-11 03:03 capsule_manager_sdk-0.2.0.dev20240411.dist-info/WHEEL
+-rw-r--r--  2.0 unx      108 b- defN 24-Apr-11 03:03 capsule_manager_sdk-0.2.0.dev20240411.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        8 b- defN 24-Apr-11 03:03 capsule_manager_sdk-0.2.0.dev20240411.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1626 b- defN 24-Apr-11 03:03 capsule_manager_sdk-0.2.0.dev20240411.dist-info/RECORD
+20 files, 77276 bytes uncompressed, 20069 bytes compressed:  74.0%
```

## zipnote {}

```diff
@@ -1,43 +1,19 @@
-Filename: cli/
-Comment: 
-
-Filename: sdc/
-Comment: 
-
-Filename: capsule_manager_sdk-0.1.3b0.dist-info/
-Comment: 
-
-Filename: capsule_manager_sdk.libs/
-Comment: 
-
 Filename: cli/__init__.py
 Comment: 
 
 Filename: cli/cms.py
 Comment: 
 
 Filename: cli/cms_config.py
 Comment: 
 
 Filename: cli/cms_util.py
 Comment: 
 
-Filename: sdc/crypto/
-Comment: 
-
-Filename: sdc/lib/
-Comment: 
-
-Filename: sdc/ual/
-Comment: 
-
-Filename: sdc/util/
-Comment: 
-
 Filename: sdc/__init__.py
 Comment: 
 
 Filename: sdc/capsule_manager_frame.py
 Comment: 
 
 Filename: sdc/error.py
@@ -48,29 +24,14 @@
 
 Filename: sdc/crypto/asymm.py
 Comment: 
 
 Filename: sdc/crypto/symm.py
 Comment: 
 
-Filename: sdc/lib/libgeneration.cpython-38-x86_64-linux-gnu.so
-Comment: 
-
-Filename: sdc/lib/libverification.cpython-38-x86_64-linux-gnu.so
-Comment: 
-
-Filename: sdc/ual/__init__.py
-Comment: 
-
-Filename: sdc/ual/constants.py
-Comment: 
-
-Filename: sdc/ual/ual.py
-Comment: 
-
 Filename: sdc/util/__init__.py
 Comment: 
 
 Filename: sdc/util/constants.py
 Comment: 
 
 Filename: sdc/util/crypto.py
@@ -78,23 +39,23 @@
 
 Filename: sdc/util/file.py
 Comment: 
 
 Filename: sdc/util/tool.py
 Comment: 
 
-Filename: capsule_manager_sdk-0.1.3b0.dist-info/METADATA
+Filename: capsule_manager_sdk-0.2.0.dev20240411.dist-info/METADATA
 Comment: 
 
-Filename: capsule_manager_sdk-0.1.3b0.dist-info/WHEEL
+Filename: capsule_manager_sdk-0.2.0.dev20240411.dist-info/WHEEL
 Comment: 
 
-Filename: capsule_manager_sdk-0.1.3b0.dist-info/entry_points.txt
+Filename: capsule_manager_sdk-0.2.0.dev20240411.dist-info/entry_points.txt
 Comment: 
 
-Filename: capsule_manager_sdk-0.1.3b0.dist-info/top_level.txt
+Filename: capsule_manager_sdk-0.2.0.dev20240411.dist-info/top_level.txt
 Comment: 
 
-Filename: capsule_manager_sdk-0.1.3b0.dist-info/RECORD
+Filename: capsule_manager_sdk-0.2.0.dev20240411.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=store
+Zip archive data, at least v2.0 to extract, compression method=deflate
```

## cli/cms.py

```diff
@@ -8,21 +8,22 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+import base64
 import os
 from typing import List
+
 import click
-import base64
-from sdc.util import file
-from sdc import capsule_manager_frame
 from google.protobuf import json_format
+from sdc import capsule_manager_frame
+from sdc.util import file
 
 current_work_dir = os.path.dirname(__file__)
 CONFIG_FILE = current_work_dir + "/cms/cli.yaml"
 
 
 def read_rsa_keypair(cfg) -> tuple:
     if (
@@ -48,14 +49,25 @@
     "--config-file", type=click.STRING, default=CONFIG_FILE, help="the config path"
 )
 @click.pass_context
 def cms(ctx, config_file):
     global CONFIG_FILE
     CONFIG_FILE = config_file
     config = file.read_yaml_file(CONFIG_FILE)
+    tee_constraints = config["tee_constraints"]
+    mr_plat = (
+        tee_constraints["mr_plat"] if tee_constraints["mr_plat"] is not None else ""
+    )
+    mr_boot = (
+        tee_constraints["mr_boot"] if tee_constraints["mr_boot"] is not None else ""
+    )
+    mr_ta = tee_constraints["mr_ta"] if tee_constraints["mr_ta"] is not None else ""
+    mr_signer = (
+        tee_constraints["mr_signer"] if tee_constraints["mr_signer"] is not None else ""
+    )
 
     if (
         config["root_ca_file"] is not None
         and config["private_key_file"] is not None
         and config["cert_chain_file"] is not None
     ):
         root_ca: bytes = file.read_file(config["root_ca_file"], "r").encode("utf-8")
@@ -64,21 +76,24 @@
         )
         cert_chain: bytes = file.read_file(config["cert_chain_file"], "r").encode(
             "utf-8"
         )
 
         ctx.obj = capsule_manager_frame.CapsuleManagerFrame(
             config["host"],
-            config["mr_enclave"],
+            config["tee_plat"],
+            capsule_manager_frame.TeeConstraints(mr_plat, mr_boot, mr_ta, mr_signer),
             capsule_manager_frame.CredentialsConf(root_ca, private_key, cert_chain),
-            config["sim"],
         )
     else:
         ctx.obj = capsule_manager_frame.CapsuleManagerFrame(
-            config["host"], config["mr_enclave"], None, config["sim"]
+            config["host"],
+            config["tee_plat"],
+            capsule_manager_frame.TeeConstraints(mr_plat, mr_boot, mr_ta, mr_signer),
+            None,
         )
 
 
 @cms.command()
 @click.pass_context
 def get_public_key(ctx):
     """
@@ -99,57 +114,37 @@
     cert_pems, private_key = read_rsa_keypair(config)
 
     ctx.obj.register_cert(config["party_id"], cert_pems, config["scheme"], private_key)
 
 
 @cms.command()
 @click.pass_context
-def get_data_keys(ctx):
-    """
-    get data_keys of several resource_uris from CapsuleManager
-    """
-    config = file.read_yaml_file(CONFIG_FILE)
-    common = config["common"]
-    ownered = config["get_data_keys"]
-    cert_pems, private_key = read_rsa_keypair(common)
-
-    result = ctx.obj.get_data_keys(
-        ownered["initiator_party_id"],
-        ownered["scope"],
-        ownered["op_name"],
-        ownered["resource_uris"],
-        ownered["env"],
-        ownered["global_attrs"],
-        ownered["columns"],
-        ownered["attrs"],
-        cert_pems,
-        private_key,
-    )
-    result = [
-        (resource_uri, data_key, base64.b64encode(data_key).decode("utf-8"))
-        for (resource_uri, data_key) in result
-    ]
-    print(result)
-
-
-@cms.command()
-@click.pass_context
 def register_data_keys(ctx):
     """
     upload data_keys of several resource_uris to CapsuleManager
     """
     config = file.read_yaml_file(CONFIG_FILE)
     common = config["common"]
     ownered = config["register_data_keys"]
     cert_pems, private_key = read_rsa_keypair(common)
 
-    data_keys = [base64.b64decode(data_key) for data_key in ownered["data_key_b64s"]]
+    data_keys = ownered["data_keys"]
+
+    # check data_key_b64 format
+    for data_key in data_keys:
+        data_key_b64 = data_key.get("data_key_b64")
+        try:
+            base64.b64decode(data_key_b64, validate=True)
+        except (ValueError, base64.binascii.Error):
+            raise ValueError(
+                f"The provided data_key_b64: {data_key_b64} is not a valid base64 encoded string"
+            )
+
     ctx.obj.create_data_keys(
         common["party_id"],
-        ownered["resource_uris"],
         data_keys,
         cert_pems,
         private_key,
     )
 
 
 @cms.command()
@@ -181,20 +176,15 @@
     ownered = config["register_data_policy"]
     cert_pems, private_key = read_rsa_keypair(common)
 
     ctx.obj.create_data_policy(
         common["party_id"],
         ownered["scope"],
         ownered["data_uuid"],
-        ownered["rule_ids"],
-        ownered["grantee_party_ids"],
-        ownered["columns"],
-        ownered["global_constraints"],
-        ownered["op_constraints_name"],
-        ownered["op_constraints_body"],
+        ownered["rules"],
         cert_pems,
         private_key,
     )
 
 
 @cms.command()
 @click.pass_context
@@ -227,20 +217,15 @@
     ownered = config["add_data_rule"]
     cert_pems, private_key = read_rsa_keypair(common)
 
     ctx.obj.add_data_rule(
         common["party_id"],
         ownered["scope"],
         ownered["data_uuid"],
-        ownered["rule_id"],
-        ownered["grantee_party_ids"],
-        ownered["columns"],
-        ownered["global_constraints"],
-        ownered["op_constraints_name"],
-        ownered["op_constraints_body"],
+        ownered["rule"],
         cert_pems,
         private_key,
     )
 
 
 @cms.command()
 @click.pass_context
@@ -261,32 +246,32 @@
         cert_pems,
         private_key,
     )
 
 
 @cms.command()
 @click.pass_context
-def get_export_data_key(ctx):
+def get_export_data_key_b64(ctx):
     """
-    get the data key of export data(often is generated from origin
+    get the base64 encoded data key of export data(often is generated from origin
     datas of multiply differernt partys) from CapsuleManager
     """
     config = file.read_yaml_file(CONFIG_FILE)
     common = config["common"]
-    ownered = config["get_export_data_key"]
+    ownered = config["get_export_data_key_b64"]
     cert_pems, private_key = read_rsa_keypair(common)
 
-    data_key = ctx.obj.get_export_data_key(
+    data_key = ctx.obj.get_export_data_key_b64(
         common["party_id"],
         ownered["resource_uri"],
         file.read_file(ownered["data_export_certificate_file"], "r"),
         cert_pems,
         private_key,
     )
-    print(data_key, base64.b64encode(data_key))
+    print(data_key)
 
 
 @cms.command()
 @click.pass_context
 def delete_data_key(ctx):
     """
     delete the data key of a specific resource_uri from CapsuleManager
```

## cli/cms_config.py

```diff
@@ -9,21 +9,27 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 import os
-import click
 import stat
-import yaml
+
+import click
+from ruamel.yaml import YAML
 
 current_work_dir = os.path.dirname(__file__)
 CONFIG_FILE = current_work_dir + "/cms/cli.yaml"
 
+# init yaml
+yaml = YAML()
+yaml.preserve_quotes = True
+yaml.indent(offset=2)
+
 
 def restore_config(cfg: dict):
     with open(CONFIG_FILE + ".bak", "w") as f:
         yaml.dump(cfg, f)
     os.remove(CONFIG_FILE)
     os.rename(CONFIG_FILE + ".bak", CONFIG_FILE)
     os.chmod(CONFIG_FILE, stat.S_IRWXU + stat.S_IRWXG + stat.S_IRWXO)
@@ -39,24 +45,45 @@
 @click.option(
     "--config-file", type=click.STRING, default=CONFIG_FILE, help="config file path"
 )
 def cms_config(ctx, config_file):
     global CONFIG_FILE
     CONFIG_FILE = config_file
     with open(CONFIG_FILE) as f:
-        config = yaml.safe_load(f)
+        config = yaml.load(f)
     ctx.obj = config
 
 
 @cms_config.command()
 @click.option("--host", type=click.STRING, help="the host of capsule manager")
 @click.option(
-    "--mr-enclave", type=click.STRING, help="the mrenclave of capsule manager"
+    "--tee-plat",
+    type=click.STRING,
+    help="the platform of tee, should be sim/sgx/tdx/csv",
+)
+@click.option(
+    "--mr-plat",
+    type=click.STRING,
+    help="the measurement of TEE implement internal stuff",
+)
+@click.option(
+    "--mr-boot",
+    type=click.STRING,
+    help="the measurement of TEE instance boot time stuff",
+)
+@click.option(
+    "--mr-ta",
+    type=click.STRING,
+    help="the static measurement of trust application when loading the code",
+)
+@click.option(
+    "--mr-signer",
+    type=click.STRING,
+    help="the measurement or other identity of the trust application signer",
 )
-@click.option("--sim", type=click.BOOL, help="the mode of capsule manager")
 @click.option(
     "--root-ca-file", type=click.STRING, help="the root CA of capsule manager"
 )
 @click.option(
     "--private-key-file",
     type=click.STRING,
     help="the private key of the party using capsule manager sdk",
@@ -64,18 +91,36 @@
 @click.option(
     "--cert-chain-file",
     type=click.STRING,
     multiple=True,
     help="the cert chain of the party using capsule manager sdk",
 )
 @click.pass_context
-def init(ctx, host, mr_enclave, sim, root_ca_file, private_key_file, cert_chain_file):
+def init(
+    ctx,
+    host,
+    tee_plat,
+    mr_plat,
+    mr_boot,
+    mr_ta,
+    mr_signer,
+    root_ca_file,
+    private_key_file,
+    cert_chain_file,
+):
     set_dict_value(ctx.obj, "host", host)
-    set_dict_value(ctx.obj, "mr_enclave", mr_enclave)
-    set_dict_value(ctx.obj, "sim", sim)
+    set_dict_value(ctx.obj, "tee_plat", tee_plat)
+
+    if "tee_constraints" not in ctx.obj:
+        ctx.obj["tee_constraints"] = {}
+    set_dict_value(ctx.obj["tee_constraints"], "mr_plat", mr_plat)
+    set_dict_value(ctx.obj["tee_constraints"], "mr_boot", mr_boot)
+    set_dict_value(ctx.obj["tee_constraints"], "mr_ta", mr_ta)
+    set_dict_value(ctx.obj["tee_constraints"], "mr_signer", mr_signer)
+
     set_dict_value(ctx.obj, "root_ca_file", root_ca_file)
     set_dict_value(ctx.obj, "private_key_file", private_key_file)
     set_dict_value(ctx.obj, "cert_chain_file", cert_chain_file)
 
     restore_config(ctx.obj)
 
 
@@ -106,53 +151,14 @@
     set_dict_value(ctx.obj["common"], "private_key_file", private_key_file)
 
     restore_config(ctx.obj)
 
 
 @cms_config.command()
 @click.option(
-    "--initiator-party-id",
-    type=click.STRING,
-    help="Identity of task initiator",
-)
-@click.option(
-    "--scope",
-    type=click.STRING,
-    default="default",
-    help="corresponding to the scope in the policy, only policies that are the same as the scope take effect",
-)
-@click.option(
-    "--op_name", type=click.STRING, help="behavior of operating on this resource"
-)
-@click.option(
-    "--env",
-    type=click.STRING,
-    help="in what environment is the data used (Json format)",
-)
-@click.option(
-    "--global-attrs",
-    type=click.STRING,
-    help="application-specific and data-independent attibutes (Json format)",
-)
-@click.pass_context
-def get_data_keys(ctx, initiator_party_id, scope, op_name, env, global_attrs):
-    if "get_data_keys" not in ctx.obj:
-        ctx.obj["get_data_keys"] = {}
-
-    set_dict_value(ctx.obj["get_data_keys"], "initiator_party_id", initiator_party_id)
-    set_dict_value(ctx.obj["get_data_keys"], "scope", scope)
-    set_dict_value(ctx.obj["get_data_keys"], "op_name", op_name)
-    set_dict_value(ctx.obj["get_data_keys"], "env", env)
-    set_dict_value(ctx.obj["get_data_keys"], "global_attrs", global_attrs)
-
-    restore_config(ctx.obj)
-
-
-@cms_config.command()
-@click.option(
     "--scope",
     type=click.STRING,
     default="default",
     help="corresponding to the scope in the policy",
 )
 @click.pass_context
 def get_data_policys(ctx, scope):
```

## cli/cms_util.py

```diff
@@ -8,22 +8,30 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+import base64
 import json
+
 import click
-import base64
-from sdc.crypto import asymm
-from sdc.util import crypto
-from sdc.util import file
-from sdc.util import tool
 from cryptography.hazmat.primitives.ciphers.aead import AESGCM
+from sdc.crypto import asymm
+from sdc.util import crypto, file, tool
+
+VOTE_REQUEST = "vote_request"
+CERT_CHAIN_FILE = "cert_chain_file"
+CERT_CHAIN = "cert_chain"
+BODY = "body"
+PRIVATE_KEY_FILE = "private_key_file"
+VOTE_REQUEST_SIGNATURE = "vote_request_signature"
+VOTER_SIGNATURE = "voter_signature"
+VOTE_INVITE = "vote_invite"
 
 
 @click.group()
 def cms_util():
     pass
 
 
@@ -178,132 +186,145 @@
     """
     data_key: bytes = base64.b64decode(data_key_b64)
     crypto.decrypt_file_inplace(file, data_key)
 
 
 @cms_util.command()
 @click.option(
-    "--config-file", type=click.STRING, required=True, help="the config file for voting"
+    "--vote-request-file",
+    type=click.STRING,
+    required=True,
+    help="the original vote request file",
+)
+@click.option(
+    "--signed-vote-request-file",
+    type=click.STRING,
+    required=True,
+    help="the signed vote request file",
 )
-def generate_voter_sign(config_file):
+def sign_vote_request(vote_request_file, signed_vote_request_file):
+    """
+    generate the vote request with signature when exporting the result data
+    """
+    config = file.read_yaml_file(vote_request_file)
+    vote_request = config[VOTE_REQUEST]
+    signed_vote_request = dict()
+
+    cert_chain = list()
+    if vote_request.get(CERT_CHAIN_FILE) is not None:
+        for filename in vote_request.pop(CERT_CHAIN_FILE):
+            cert_chain.append(file.read_file(filename, "r"))
+    signed_vote_request[CERT_CHAIN] = cert_chain
+
+    if vote_request.get(PRIVATE_KEY_FILE) is not None:
+        private_key = file.read_file(vote_request.pop(PRIVATE_KEY_FILE), "r").encode(
+            "utf-8"
+        )
+        vote_body_str = json.dumps(vote_request)
+        vote_body_b64 = base64.b64encode(vote_body_str.encode("utf-8")).decode("utf-8")
+        signed_vote_request[BODY] = vote_body_b64
+
+        # vote_request_signature
+        signature_b64 = base64.b64encode(
+            asymm.RsaSigner(private_key, "RS256")
+            .update(vote_body_b64.encode("utf-8"))
+            .sign()
+        ).decode("utf-8")
+        signed_vote_request[VOTE_REQUEST_SIGNATURE] = signature_b64
+
+    file.write_yaml_file(signed_vote_request, signed_vote_request_file)
+
+
+@cms_util.command()
+@click.option(
+    "--voter-file", type=click.STRING, required=True, help="the voter's config file"
+)
+@click.option(
+    "--signed-voter-file",
+    type=click.STRING,
+    required=True,
+    help="the voter's signed file",
+)
+def voter_sign(voter_file, signed_voter_file):
     """
     generate voter signature when exporting the result data
     """
-    config = file.read_yaml_file(config_file)
+    voter = file.read_yaml_file(voter_file)
+    voter_signed = dict()
+
+    cert_chain = list()
+    if voter.get(CERT_CHAIN_FILE) is not None:
+        for filename in voter.pop(CERT_CHAIN_FILE):
+            cert_chain.append(file.read_file(filename, "r"))
+    voter_signed[CERT_CHAIN] = cert_chain
+
     # get private key
-    private_key = file.read_file(config.pop("private_key_file"), "r").encode("utf-8")
+    private_key = file.read_file(voter.pop(PRIVATE_KEY_FILE), "r").encode("utf-8")
     # get requester's sign
-    request_sign = config.pop("vote_request_signature")
+    request_sign = voter.pop(VOTE_REQUEST_SIGNATURE)
 
-    body_str = json.dumps(config)
+    body_str = json.dumps(voter)
     body_b64 = base64.b64encode(body_str.encode("utf-8")).decode("utf-8")
-    signature = base64.b64encode(
+    voter_signed[BODY] = body_b64
+
+    signature_b64 = base64.b64encode(
         asymm.RsaSigner(private_key, "RS256")
         .update(body_b64.encode("utf-8"))
         .update(request_sign.encode("utf-8"))
         .sign()
     ).decode("utf-8")
-    print(signature)
+
+    voter_signed[VOTER_SIGNATURE] = signature_b64
+    file.write_yaml_file(voter_signed, signed_voter_file)
 
 
 @cms_util.command()
 @click.option(
-    "--config-file", type=click.STRING, required=True, help="the config file for voting"
+    "--signed-vote-request-file",
+    type=click.STRING,
+    required=True,
+    help="the signed vote request file",
 )
 @click.option(
-    "--dest-file", type=click.STRING, help="the dest file to store voting result"
+    "--signed-voter-files",
+    type=click.STRING,
+    required=True,
+    multiple=True,
+    help="the voter's signed files",
 )
-def generate_data_export_cert(config_file, dest_file):
-    """
-    generate the vote result when exporting the result data
-    """
-    config = file.read_yaml_file(config_file)
-    # config["vote_request"]
-    vote_request_config = dict()
-    # cert_chain
-    cert_pems_str = list()
-    for filename in config["vote_request"].pop("cert_chain_file"):
-        cert_pems_str.append(file.read_file(filename, "r"))
-    vote_request_config["cert_chain"] = cert_pems_str
-
-    # signature
-    if config["vote_request"]["vote_request_signature"]:
-        vote_request_signature = config["vote_request"]["vote_request_signature"]
-    config["vote_request"].pop("vote_request_signature", None)
-
-    # private-key
-    if config["vote_request"]["private_key_file"]:
-        private_key = file.read_file(
-            config["vote_request"]["private_key_file"], "r"
-        ).encode("utf-8")
-    config["vote_request"].pop("private_key_file", None)
-
-    # body
-    vote_body_str = json.dumps(config["vote_request"])
-    vote_request_config["body"] = base64.b64encode(
-        vote_body_str.encode("utf-8")
-    ).decode("utf-8")
+@click.option(
+    "--vote-result-file",
+    type=click.STRING,
+    required=True,
+    help="the file to store voting result",
+)
+def generate_vote_result(
+    signed_vote_request_file, signed_voter_files, vote_result_file
+):
+    """
+    generate vote result json from signed-vote-request-file and signed-voter-files
+    """
+    vote_result_config = dict()
+
+    vote_request = dict()
+    vote_request_config = file.read_yaml_file(signed_vote_request_file)
+    vote_request[CERT_CHAIN] = vote_request_config[CERT_CHAIN]
+    vote_request[BODY] = vote_request_config[BODY]
+    vote_request[VOTE_REQUEST_SIGNATURE] = vote_request_config[VOTE_REQUEST_SIGNATURE]
+
+    vote_invite = list()
+    for signed_voter_file in signed_voter_files:
+        signed_voter_config = file.read_yaml_file(signed_voter_file)
+        vote_invite_item = dict()
+        vote_invite_item[CERT_CHAIN] = signed_voter_config[CERT_CHAIN]
+        vote_invite_item[BODY] = signed_voter_config[BODY]
+        vote_invite_item[VOTER_SIGNATURE] = signed_voter_config[VOTER_SIGNATURE]
+        vote_invite.append(vote_invite_item)
 
-    # vote_request_signature
-    if private_key:
-        vote_request_config["vote_request_signature"] = base64.b64encode(
-            asymm.RsaSigner(private_key, "RS256")
-            .update(vote_request_config["body"].encode("utf-8"))
-            .sign()
-        ).decode("utf-8")
-    else:
-        vote_request_config["vote_request_signature"] = vote_request_signature
+    vote_result_config[VOTE_REQUEST] = vote_request
+    vote_result_config[VOTE_INVITE] = vote_invite
 
-    # config["vote_invite"]
-    invite_list_config = list()
-    if "vote_invite" in config and config["vote_invite"]:
-        for invite in config["vote_invite"]:
-            invite_config = dict()
-            # cert_chain
-            cert_pems_str = list()
-            for filename in invite.pop("cert_chain_file"):
-                cert_pems_str.append(file.read_file(filename, "r"))
-            invite_config["cert_chain"] = cert_pems_str
-
-            # signature
-            voter_signature = invite.pop("voter_signature", None)
-
-            # private key
-            invite_private_key = invite.pop("private_key_file", None)
-            if invite_private_key:
-                invite_private_key = file.read_file(invite_private_key, "r").encode(
-                    "utf-8"
-                )
-
-            # body
-            invite_body_str = json.dumps(invite)
-            invite_config["body"] = base64.b64encode(
-                invite_body_str.encode("utf-8")
-            ).decode("utf-8")
-
-            if invite_private_key:
-                invite_config["voter_signature"] = base64.b64encode(
-                    asymm.RsaSigner(invite_private_key, "RS256")
-                    .update(invite_config["body"].encode("utf-8"))
-                    .update(
-                        vote_request_config["vote_request_signature"].encode("utf-8")
-                    )
-                    .sign()
-                ).decode("utf-8")
-            else:
-                invite_config["voter_signature"] = voter_signature
-
-            invite_list_config.append(invite_config)
-
-    # compose
-    cfg = dict()
-    cfg["vote_request"] = vote_request_config
-    cfg["vote_invite"] = invite_list_config
-
-    if dest_file:
-        file.write_file(dest_file, "w", json.dumps(cfg))
-    else:
-        print(json.dumps(cfg))
+    file.write_file(vote_result_file, "w", json.dumps(vote_result_config))
 
 
 if __name__ == "__main__":
     cms_util()
```

## sdc/capsule_manager_frame.py

```diff
@@ -9,65 +9,99 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 import base64
-import grpc
-
 from dataclasses import dataclass
 from typing import List, Union
-from google.protobuf import json_format
-from google.protobuf import message
+
+import grpc
+from cryptography import x509
 from cryptography.hazmat.primitives import serialization
 from cryptography.hazmat.primitives.asymmetric import rsa
 from cryptography.hazmat.primitives.ciphers.aead import AESGCM
-from cryptography import x509
+from google.protobuf import json_format, message
 from sdc.crypto import asymm, symm
 from sdc.error import CapsuleManagerError
 from sdc.util import crypto, tool
-from sdc.ual.constants import NONCE_SIZE_IN_SIZE
-from secretflowapis.v2.sdc import ual_pb2
-from secretflowapis.v2.sdc import jwt_pb2
+from secretflowapis.v2.sdc import jwt_pb2, ual_pb2
 from secretflowapis.v2.sdc.capsule_manager import (
     capsule_manager_pb2,
     capsule_manager_pb2_grpc,
 )
 
+NONCE_SIZE_IN_SIZE = 32
+
+# tee plat types
+TEE_PLAT_SIM = "sim"
+TEE_PLAT_SGX = "sgx"
+TEE_PLAT_TDX = "tdx"
+TEE_PLAT_CSV = "csv"
+
+# tee plat types in UAL Protobuf
+UAL_TEE_PLAT_SGX = "SGX_DCAP"
+UAL_TEE_PLAT_TDX = "TDX"
+UAL_TEE_PLAT_CSV = "CSV"
+
+RESOURCE_URI = "resource_uri"
+DATA_KEY_B64 = "data_key_b64"
+RULE_ID = "rule_id"
+GRANTEE_PARTY_IDS = "grantee_party_ids"
+COLUMNS = "columns"
+GLOBAL_CONSTRAINTS = "global_constraints"
+OP_CONSTRAINS = "op_constraints"
+OP_NAME = "op_name"
+CONSTRAINTS = "constraints"
+
 
 @dataclass
 class CredentialsConf:
     root_ca: bytes
     private_key: bytes
     cert_chain: bytes
 
 
+@dataclass
+class TeeConstraints:
+    mr_plat: str
+    mr_boot: str
+    mr_ta: str
+    mr_signer: str
+
+
 class CapsuleManagerFrame(object):
-    def __init__(self, host: str, mr_enclave: str, conf: CredentialsConf, sim=False):
+    def __init__(
+        self,
+        host: str,
+        tee_plat: str,
+        tee_constraints: TeeConstraints,
+        conf: CredentialsConf,
+    ):
         """CapsuleManager client
 
         Args:
             host: CapsuleManager endpoint
-            mr_enclave: CapsuleManager mr_enclave
-            sim (bool, optional): is in simulation mode. Defaults to False.
+            tee_plat: Tee platform, sim/sgx/tdx/csv
+            tee_constraints: CapsuleManager's measurement constraints
         """
-        self.sim = sim
+        self.tee_plat = tee_plat
+        self.tee_constraints = tee_constraints
         if conf is None:
             channel = grpc.insecure_channel(host)
         else:
             credentials = grpc.ssl_channel_credentials(
                 root_certificates=conf.root_ca,
                 private_key=conf.private_key,
                 certificate_chain=conf.cert_chain,
             )
             channel = grpc.secure_channel(host, credentials)
 
         self.stub = capsule_manager_pb2_grpc.CapsuleManagerStub(channel)
-        self.mr_enclave = mr_enclave if mr_enclave is not None else ""
 
     @staticmethod
     def create_encrypted_request(
         request: message.Message,
         public_key: bytes,
         private_key: Union[bytes, str, rsa.RSAPrivateKey],
         cert_pems: List[bytes] = None,
@@ -166,34 +200,59 @@
         )
         json_format.Parse(plain_text, msg)
 
     def get_public_key(self) -> bytes:
         """Get CapsuleManager public key"""
         request = capsule_manager_pb2.GetRaCertRequest()
         nonce_bytes = crypto.gen_key(32)
-        request.nonce = tool.to_upper_hex(nonce_bytes)
+        request.nonce = tool.to_hex(nonce_bytes)
         response = self.stub.GetRaCert(request)
         if response.status.code != 0:
             raise CapsuleManagerError(response.status.code, response.status.message)
         assert len(response.cert) != 0, "The CapsuleManager should have public key."
 
-        if not self.sim:
-            from sdc.ual import ual
-            
+        if self.tee_plat != TEE_PLAT_SIM:
+            from trustedflow.attestation.verification import verifier
+
             policy = ual_pb2.UnifiedAttestationPolicy()
             rule = policy.main_attributes.add()
-            rule.str_tee_platform = "SGX_DCAP"
-            rule.hex_ta_measurement = self.mr_enclave
-            rule.bool_debug_disabled = "1"
 
             user_data = crypto.sha256(
                 response.cert.encode("utf-8"), request.nonce.encode("utf-8")
             )
-            rule.hex_user_data = tool.to_upper_hex(user_data)
-            ual.verify_report(response.attestation_report, policy)
+            rule.hex_user_data = tool.to_hex(user_data)
+
+            if self.tee_plat == TEE_PLAT_SGX:
+                rule.bool_debug_disabled = "true"
+                rule.str_tee_platform = UAL_TEE_PLAT_SGX
+                rule.hex_ta_measurement = self.tee_constraints.mr_ta
+                rule.hex_signer = self.tee_constraints.mr_signer
+            elif self.tee_plat == TEE_PLAT_TDX:
+                rule.bool_debug_disabled = "true"
+                rule.str_tee_platform = UAL_TEE_PLAT_TDX
+                rule.hex_platform_measurement = self.tee_constraints.mr_plat
+                rule.hex_boot_measurement = self.tee_constraints.mr_boot
+                rule.hex_ta_measurement = self.tee_constraints.mr_ta
+            elif self.tee_plat == TEE_PLAT_CSV:
+                rule.str_tee_platform = UAL_TEE_PLAT_CSV
+                rule.hex_boot_measurement = self.tee_constraints.mr_boot
+            else:
+                raise ValueError(f"Invalid TEE platform: {self.tee_plat}")
+
+            report_json = json_format.MessageToJson(
+                response.attestation_report, including_default_value_fields=True
+            )
+            policy_json = json_format.MessageToJson(
+                policy, including_default_value_fields=True
+            )
+            verify_status = verifier.attestation_report_verify(report_json, policy_json)
+            if verify_status.code != 0:
+                raise RuntimeError(
+                    f"attestation_report_verify failed. Code:{verify_status.code}, Message:{verify_status.message}, Details:{verify_status.details}."
+                )
 
         cert = x509.load_pem_x509_certificate(response.cert.encode("utf-8"))
         return cert.public_key().public_bytes(
             encoding=serialization.Encoding.PEM,
             format=serialization.PublicFormat.SubjectPublicKeyInfo,
         )
 
@@ -224,166 +283,37 @@
             )
         )
         if encrypted_response.status.code != 0:
             raise CapsuleManagerError(
                 encrypted_response.status.code, encrypted_response.status.message
             )
 
-    def get_data_keys(
-        self,
-        initiator_party_id: str,
-        scope: str,
-        op_name: str,
-        resource_uris: List[str],
-        env: str = None,
-        global_attrs: str = None,
-        columns: List[List[str]] = None,
-        attrs: List[str] = None,
-        cert_pems: List[bytes] = None,
-        private_key: Union[bytes, str, rsa.RSAPrivateKey] = None,
-    ) -> List[tuple]:
-        """Get data keys
-
-        Args:
-            initiator_party_id: Identity of task initiator
-            scope: Corresponding to the `scope` in the `Policy`,
-                only policies that are the same as the scope take effect
-            op_name: Behavior of operating on this resource
-            env: In what environment is the data used (Json format)
-                egg:
-                {
-                        "execution_time": "2023-07-12T12:00:00",
-                        "tee": {
-                           "type": "sgx2",
-                           "mr_enclave": "#####"
-                        }
-                }
-            global_attrs: Application-specific and data-independent attibutes (Json format)
-                egg:
-                {
-                    "xgb": {
-                        "tree_num": 1
-                    }
-                }
-            resource_uris: list of Resource that need to be accessed,
-                URI format: {data_uuid}/{partition_id}/{segment_id}
-            columns: if this is a structued data, specify which columns will be used
-            attrs: application-specific and data-dependent attributes (Json format)
-                egg:
-                {
-                    "join": [
-                        "join_key": ["id"],
-                            "reference_key": {
-                            "data_uuid": "t2",
-                            "join_key": ["id"]
-                            }
-                    ]
-                }
-            cert_pems: cert chain of party
-            private_key: private key of party
-
-            Notice: len(resource_uris) = len(columns) = len(attrs)
-
-        Returns:
-            List[(bytes, bytes)]: The data keys in the list correspond one-to-one to the elements in the resource_uri
-        """
-        resource_request = capsule_manager_pb2.ResourceRequest()
-        resource_request.initiator_party_id = initiator_party_id
-        resource_request.scope = scope
-        resource_request.op_name = op_name
-        if env is not None:
-            resource_request.env = env
-        if global_attrs is not None:
-            resource_request.global_attrs = global_attrs
-
-        tool.assert_list_len_equal(
-            resource_uris, columns, "len(resource_uris) != len(columns)"
-        )
-        tool.assert_list_len_equal(
-            resource_uris, attrs, "len(resource_uris) != len(attrs)"
-        )
-
-        for index in range(len(resource_uris)):
-            resource = resource_request.resources.add()
-            resource.resource_uri = resource_uris[index]
-            if columns is not None:
-                resource.columns.extend(columns[index])
-            if attrs is not None:
-                resource.attrs = attrs[index]
-
-        if private_key is None:
-            # Generate temp RSA key-pair
-            (private_key, cert_pems) = crypto.generate_rsa_keypair()
-
-        # call authmanager service
-        request = capsule_manager_pb2.GetDataKeysRequest()
-
-        request.resource_request.CopyFrom(resource_request)
-        if cert_pems is not None and len(cert_pems) > 0:
-            request.cert = cert_pems[0].decode("utf-8")
-        # Generate RA Report
-        if not self.sim:
-            digest = crypto.sha256(
-                cert_pems[0],
-                request.resource_request.SerializeToString(deterministic=True),
-            )
-            report = ual.create_report("Passport", tool.to_upper_hex(digest))
-            request.attestation_report.CopyFrom(report)
-
-        # encrypt request
-        encrypted_response = self.stub.GetDataKeys(
-            self.create_encrypted_request(
-                request, self.get_public_key(), private_key, cert_pems
-            )
-        )
-        if encrypted_response.status.code != 0:
-            raise CapsuleManagerError(
-                encrypted_response.status.code, encrypted_response.status.message
-            )
-
-        # decrypt request
-        response = capsule_manager_pb2.GetDataKeysResponse()
-        self.parse_from_encrypted_response(encrypted_response, private_key, response)
-
-        return [
-            (data_key.resource_uri, base64.b64decode(data_key.data_key_b64))
-            for data_key in response.data_keys
-        ]
-
     def create_data_keys(
         self,
         owner_party_id: str,
-        resource_uris: List[str],
-        data_keys: List[bytes],
+        data_keys: List[dict],
         cert_pems: List[bytes] = None,
         private_key: Union[bytes, str, rsa.RSAPrivateKey] = None,
     ):
         """create data keys
 
         Args:
             owner_party_id: data owner
-            resource_uris: list of Resource that need to be accessed,
-                URI format: {data_uuid}/{partition_id}/{segment_id}
-            data_keys: list of data_key for every resource_uri
+            data_keys: list of data_key, data_key is a dict contains "resource_uri" and "data_key_b64"
             cert_pems: cert chain of party
             private_key: private key of party
 
-            Notice: len(resource_uris) = len(data_keys)
         """
         request = capsule_manager_pb2.CreateDataKeysRequest()
         request.owner_party_id = owner_party_id
 
-        tool.assert_list_len_equal(
-            resource_uris, data_keys, "len(resource_uris) != len(data_keys)"
-        )
-
-        for uri, data_key in zip(resource_uris, data_keys):
+        for data_key in data_keys:
             request.data_keys.add(
-                resource_uri=uri,
-                data_key_b64=base64.b64encode(data_key).decode("utf-8"),
+                resource_uri=data_key.get(RESOURCE_URI),
+                data_key_b64=data_key.get(DATA_KEY_B64),
             )
 
         if private_key is None:
             # Generate temp RSA key-pair
             (private_key, cert_pems) = crypto.generate_rsa_keypair()
 
         encrypted_response = self.stub.CreateDataKeys(
@@ -438,80 +368,58 @@
         return list(response.policies)
 
     def create_data_policy(
         self,
         owner_party_id: str,
         scope: str,
         data_uuid: str,
-        rule_ids: List[str],
-        grantee_party_ids: List[List[str]],
-        columns: List[List[str]] = None,
-        global_constraints: List[List[str]] = None,
-        op_constraints_name: List[List[str]] = None,
-        op_constraints_body: List[List[List[str]]] = None,
+        rules: List[dict],
         cert_pems: List[bytes] = None,
         private_key: Union[bytes, str, rsa.RSAPrivateKey] = None,
     ):
         """create data policy
 
         Args:
             owner_party_id: data owner
             scope: scope
             data_uuid: data id
-            rule_ids: list of rule
-            grantee_party_ids: for every rule, the list of party ids being guanteed
-            columns: for every rule, specify which columns can be used, if this is a structued data
-            global_constraints: for every rule, gobal DSL decribed additional constraints
-            op_constraints_name: for every rule, op name: e.g. PSI, XGB, LR, SQL
-            op_constraints_body: for every rule, DSL decribed additional constraints, working on the specified operator.
+            rules: list of rule, rule is a dict contains:
+              rule_id: id of the rule
+              grantee_party_ids: for every rule, the list of party ids being guanteed
+              columns: for every rule, specify which columns can be used, if this is a structued data
+              global_constraints: for every rule, gobal DSL decribed additional constraints
+              op_constraints: list of op_constraint, it has op_name and corresponding constraints
             cert_pems: cert chain of party
             private_key: private key of party
 
         """
         request = capsule_manager_pb2.CreateDataPolicyRequest()
         request.owner_party_id = owner_party_id
         request.scope = scope
         request.policy.data_uuid = data_uuid
 
-        tool.assert_list_len_equal(
-            rule_ids, grantee_party_ids, "len(rule_ids) != len(grantee_party_ids)"
-        )
-        tool.assert_list_len_equal(rule_ids, columns, "len(rule_ids) != len(columns)")
-        tool.assert_list_len_equal(
-            rule_ids, global_constraints, "len(rule_ids) != len(global_constraints)"
-        )
-        tool.assert_list_len_equal(
-            rule_ids, op_constraints_name, "len(rule_ids) != len(op_constraints_name)"
-        )
-        tool.assert_list_len_equal(
-            rule_ids, op_constraints_body, "len(rule_ids) != len(op_constraints_body)"
-        )
-
-        for index in range(len(rule_ids)):
-            rule = request.policy.rules.add()
-            rule.rule_id = rule_ids[index]
-            rule.grantee_party_ids.extend(grantee_party_ids[index])
-            if columns is not None:
-                rule.columns.extend(columns[index])
-            if global_constraints is not None:
-                rule.global_constraints.extend(global_constraints[index])
-            if op_constraints_name is not None and op_constraints_body is not None:
-                tool.assert_list_len_equal(
-                    op_constraints_name[index],
-                    op_constraints_body[index],
-                    f"len(op_constraints_name[{index}]) != len(op_constraints_body[{index}])",
-                )
-
-                for name, constraint in zip(
-                    op_constraints_name[index], op_constraints_body[index]
-                ):
-                    rule.op_constraints.add(op_name=name, constraints=constraint)
-            elif op_constraints_name is not None:
-                for name in op_constraints_name[index]:
-                    rule.op_constraints.add(op_name=name, constraints=[])
+        for rule in rules:
+            rule_add = request.policy.rules.add()
+            rule_add.rule_id = rule.get(RULE_ID)
+            if rule.get(GRANTEE_PARTY_IDS) is not None:
+                rule_add.grantee_party_ids.extend(rule.get(GRANTEE_PARTY_IDS))
+            if rule.get(COLUMNS) is not None:
+                rule_add.columns.extend(rule.get(COLUMNS))
+            if rule.get(GLOBAL_CONSTRAINTS) is not None:
+                rule_add.global_constraints.extend(rule.get(GLOBAL_CONSTRAINTS))
+            if rule.get(OP_CONSTRAINS) is not None:
+                for op_constraint in rule.get(OP_CONSTRAINS):
+                    constraints = (
+                        op_constraint.get(CONSTRAINTS)
+                        if op_constraint.get(CONSTRAINTS) is not None
+                        else []
+                    )
+                    rule_add.op_constraints.add(
+                        op_name=op_constraint.get(OP_NAME), constraints=constraints
+                    )
 
         if private_key is None:
             # Generate temp RSA key-pair
             (private_key, cert_pems) = crypto.generate_rsa_keypair()
 
         encrypted_response = self.stub.CreateDataPolicy(
             self.create_encrypted_request(
@@ -561,59 +469,56 @@
             )
 
     def add_data_rule(
         self,
         owner_party_id: str,
         scope: str,
         data_uuid: str,
-        rule_id: str,
-        grantee_party_ids: List[str],
-        columns: List[str],
-        global_constraints: List[str],
-        op_constraints_name: List[str] = None,
-        op_constraints_body: List[List[str]] = None,
+        rule: dict,
         cert_pems: List[bytes] = None,
         private_key: Union[bytes, str, rsa.RSAPrivateKey] = None,
     ):
         """add data rule
 
         Args:
             owner_party_id: data owner
             scope: scope
             data_uuid: data id
-            rule_id: identifier of the rule
-            grantee_party_ids: the list of party ids being guanteed
-            columns:  specify which columns can be used, if this is a structued data
-            global_constraints: gobal DSL decribed additional constraints
-            op_constraints_name: op name: e.g. PSI, XGB, LR, SQL
-            op_constraints_body: DSL decribed additional constraints, working on the specified operator.
+            rule: rule is a dict contains:
+              rule_id: id of the rule
+              grantee_party_ids: for every rule, the list of party ids being guanteed
+              columns: for every rule, specify which columns can be used, if this is a structued data
+              global_constraints: for every rule, gobal DSL decribed additional constraints
+              op_constraints: list of op_constraint, it has op_name and corresponding constraints
             cert_pems: cert chain of party
             private_key: private key of party
 
         """
         request = capsule_manager_pb2.AddDataRuleRequest()
         request.owner_party_id = owner_party_id
         request.data_uuid = data_uuid
         request.scope = scope
-        request.rule.rule_id = rule_id
-        request.rule.grantee_party_ids.extend(grantee_party_ids)
 
-        tool.assert_list_len_equal(
-            op_constraints_name,
-            op_constraints_body,
-            "len(op_constraints_name) != len(op_constraints_body)",
-        )
-
-        if columns is not None:
-            request.rule.columns.extend(columns)
-        if global_constraints is not None:
-            request.rule.global_constraints.extend(global_constraints)
-        if op_constraints_name is not None and op_constraints_body is not None:
-            for name, constraint in zip(op_constraints_name, op_constraints_body):
-                request.rule.op_constraints.add(op_name=name, constraints=constraint)
+        request.rule.rule_id = rule.get(RULE_ID)
+        if rule.get(GRANTEE_PARTY_IDS) is not None:
+            request.rule.grantee_party_ids.extend(rule.get(GRANTEE_PARTY_IDS))
+        if rule.get(COLUMNS) is not None:
+            request.rule.columns.extend(rule.get(COLUMNS))
+        if rule.get(GLOBAL_CONSTRAINTS) is not None:
+            request.rule.global_constraints.extend(rule.get(GLOBAL_CONSTRAINTS))
+        if rule.get(OP_CONSTRAINS) is not None:
+            for op_constraint in rule.get(OP_CONSTRAINS):
+                constraints = (
+                    op_constraint.get(CONSTRAINTS)
+                    if op_constraint.get(CONSTRAINTS) is not None
+                    else []
+                )
+                request.rule.op_constraints.add(
+                    op_name=op_constraint.get(OP_NAME), constraints=constraints
+                )
 
         if private_key is None:
             # Generate temp RSA key-pair
             (private_key, cert_pems) = crypto.generate_rsa_keypair()
 
         encrypted_response = self.stub.AddDataRule(
             self.create_encrypted_request(
@@ -661,23 +566,23 @@
             )
         )
         if encrypted_response.status.code != 0:
             raise CapsuleManagerError(
                 encrypted_response.status.code, encrypted_response.status.message
             )
 
-    def get_export_data_key(
+    def get_export_data_key_b64(
         self,
         request_party_id: str,
         resource_uri: str,
         data_export_certificate: str,
         cert_pems: List[bytes] = None,
         private_key: Union[bytes, str, rsa.RSAPrivateKey] = None,
-    ) -> bytes:
-        """get export data key
+    ) -> str:
+        """get export base64 encoded data key
 
         Args:
             request_party_id: the request owner
             resource_uri: the identifier of resource
             data_export_certificate: Data Export Certificate, json format
                 When the data request exporting party requests to obtain the decryption key
                 for accessing the data, they need to obtain the signatures of all the
@@ -701,15 +606,15 @@
         if encrypted_response.status.code != 0:
             raise CapsuleManagerError(
                 encrypted_response.status.code, encrypted_response.status.message
             )
         # decrypt request
         response = capsule_manager_pb2.GetExportDataKeyResponse()
         self.parse_from_encrypted_response(encrypted_response, private_key, response)
-        return base64.b64decode(response.data_key.data_key_b64)
+        return response.data_key.data_key_b64
 
     def delete_data_key(
         self,
         owner_party_id: str,
         resource_uri: str,
         cert_pems: List[bytes] = None,
         private_key: Union[bytes, str, rsa.RSAPrivateKey] = None,
```

## sdc/crypto/symm.py

```diff
@@ -10,14 +10,15 @@
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 from abc import ABC, abstractmethod
 from typing import Union
+
 from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
 
 
 class Encryptor(ABC):
     def __init__(self, name: str):
         """init Encryptor
```

## sdc/util/crypto.py

```diff
@@ -8,28 +8,27 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from io import BufferedWriter
+import datetime
 import os
 import secrets
-import datetime
-from cryptography.hazmat.primitives.asymmetric import rsa
+from io import BufferedWriter
 from typing import List
-from cryptography.x509.oid import NameOID
-from cryptography import x509
-from cryptography.hazmat.primitives import serialization
 
-from cryptography.hazmat.primitives import hashes, hmac
-from sdc.util.tool import bytes2int
-from sdc.util import constants
+from cryptography import x509
+from cryptography.hazmat.primitives import hashes, hmac, serialization
+from cryptography.hazmat.primitives.asymmetric import rsa
+from cryptography.x509.oid import NameOID
 from sdc.crypto import symm
+from sdc.util import constants
+from sdc.util.tool import bytes2int
 
 
 def hmac_sha256(key: bytes, *args: bytes) -> bytes:
     h = hmac.HMAC(key, hashes.SHA256())
     assert (
         len(args) >= 1
     ), "At least one piece of data is involved in the calculation of hmac."
```

## sdc/util/file.py

```diff
@@ -9,25 +9,36 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 from typing import Any
-import yaml
+
+from ruamel.yaml import YAML
+
+# init yaml
+yaml = YAML()
+yaml.preserve_quotes = True
+yaml.indent(offset=2)
 
 
 def read_file(file_path: str, mode: str):
     with open(file_path, mode) as f:
         res = f.read()
     return res
 
 
+def write_file(file_path: str, mode: str, content: Any):
+    with open(file_path, mode) as f:
+        f.write(content)
+
+
 def read_yaml_file(file_path: str):
     with open(file_path) as f:
-        res = yaml.safe_load(f)
+        res = yaml.load(f)
     return res
 
 
-def write_file(file_path: str, mode: str, content: Any):
-    with open(file_path, mode) as f:
-        f.write(content)
+def write_yaml_file(content: dict, file_path: str):
+    with open(file_path, "w") as f:
+        yaml.dump(content, f)
```

## sdc/util/tool.py

```diff
@@ -9,18 +9,19 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 import base64
-from sdc.util import crypto
-from cryptography.hazmat.primitives.asymmetric import rsa
-from cryptography.hazmat.primitives import serialization
+
 from cryptography import x509
+from cryptography.hazmat.primitives import serialization
+from cryptography.hazmat.primitives.asymmetric import rsa
+from sdc.util import crypto
 
 
 def assert_list_len_equal(
     l1: list = None, l2: list = None, msg: str = "the len of list not equal"
 ):
     if l1 is not None and l2 is not None:
         assert len(l1) == len(l2), msg
@@ -29,16 +30,16 @@
 def bytes2int(buf: bytes):
     res = 0
     for index in range(len(buf)):
         res = res << 8 | buf[len(buf) - index - 1]
     return res
 
 
-def to_upper_hex(data: bytes):
-    return "".join("{:02X}".format(x) for x in data)
+def to_hex(data: bytes):
+    return "".join("{:02x}".format(x) for x in data)
 
 
 def encode_base64(input_bytes: bytes, urlsafe: bool = True) -> str:
     """Encode bytes as an unpadded base64 string."""
 
     if urlsafe:
         encode = base64.urlsafe_b64encode
```

## Comparing `capsule_manager_sdk-0.1.3b0.dist-info/METADATA` & `capsule_manager_sdk-0.2.0.dev20240411.dist-info/METADATA`

 * *Files 18% similar despite different names*

```diff
@@ -1,20 +1,19 @@
 Metadata-Version: 2.1
 Name: capsule-manager-sdk
-Version: 0.1.3b0
+Version: 0.2.0.dev20240411
 Summary: Secure Data Capsule SDK for python
 Home-page: https://github.com/secretflow/capsule-manager-sdk.git
 Author: secretflow
 Author-email: secretflow-contact@service.alipay.com
 License: Apache 2.0
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Operating System :: POSIX :: Linux
 Description-Content-Type: text/markdown
 Requires-Dist: cryptography >=41.0.2
 Requires-Dist: grpcio
-Requires-Dist: sdc-apis ==0.2.0.dev20230930
-Requires-Dist: pyyaml
+Requires-Dist: ruamel.yaml
 Requires-Dist: click
-Requires-Dist: twine
+Requires-Dist: trustedflow-verification ==0.2.0.dev20240409
 
 Secure Data Capsule SDK for python
```

