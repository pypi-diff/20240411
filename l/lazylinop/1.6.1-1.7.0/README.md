# Comparing `tmp/lazylinop-1.6.1-py3-none-any.whl.zip` & `tmp/lazylinop-1.7.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,42 +1,44 @@
-Zip file size: 96946 bytes, number of entries: 40
--rw-r--r--  2.0 unx      126 b- defN 24-Feb-16 11:07 lazylinop/__init__.py
--rw-r--r--  2.0 unx     8275 b- defN 24-Feb-16 11:07 lazylinop/check_op.py
--rw-r--r--  2.0 unx    47849 b- defN 24-Feb-16 11:07 lazylinop/lazylinop.py
--rw-r--r--  2.0 unx      370 b- defN 24-Feb-16 11:07 lazylinop/basicops/__init__.py
--rw-r--r--  2.0 unx     1373 b- defN 24-Feb-16 11:07 lazylinop/basicops/add.py
--rw-r--r--  2.0 unx     2164 b- defN 24-Feb-16 11:07 lazylinop/basicops/blockdiag.py
--rw-r--r--  2.0 unx     1851 b- defN 24-Feb-16 11:07 lazylinop/basicops/cat.py
--rw-r--r--  2.0 unx     3839 b- defN 24-Feb-16 11:07 lazylinop/basicops/diag.py
--rw-r--r--  2.0 unx     3403 b- defN 24-Feb-16 11:07 lazylinop/basicops/eye.py
--rw-r--r--  2.0 unx     3550 b- defN 24-Feb-16 11:07 lazylinop/basicops/kron.py
--rw-r--r--  2.0 unx     2309 b- defN 24-Feb-16 11:07 lazylinop/basicops/ones.py
--rw-r--r--  2.0 unx    29888 b- defN 24-Feb-16 11:07 lazylinop/basicops/pad.py
--rw-r--r--  2.0 unx     1580 b- defN 24-Feb-16 11:07 lazylinop/basicops/zeros.py
--rw-r--r--  2.0 unx      201 b- defN 24-Feb-16 11:07 lazylinop/wip/__init__.py
--rw-r--r--  2.0 unx     1443 b- defN 24-Feb-16 11:07 lazylinop/wip/code_optimization.py
--rw-r--r--  2.0 unx     1447 b- defN 24-Feb-16 11:07 lazylinop/wip/linear_algebra.py
--rw-r--r--  2.0 unx    43982 b- defN 24-Feb-16 11:07 lazylinop/wip/polynomial.py
--rw-r--r--  2.0 unx   133585 b- defN 24-Feb-16 11:07 lazylinop/wip/signal.py
--rw-r--r--  2.0 unx    57938 b- defN 24-Feb-16 11:07 lazylinop/wip/special_matrices.py
--rw-r--r--  2.0 unx      298 b- defN 24-Feb-16 11:07 lazylinop/wip/linalg/__init__.py
--rw-r--r--  2.0 unx     4792 b- defN 24-Feb-16 11:07 lazylinop/wip/linalg/coshm.py
--rw-r--r--  2.0 unx     2880 b- defN 24-Feb-16 11:07 lazylinop/wip/linalg/cosm.py
--rw-r--r--  2.0 unx     4297 b- defN 24-Feb-16 11:07 lazylinop/wip/linalg/expm.py
--rw-r--r--  2.0 unx     5587 b- defN 24-Feb-16 11:07 lazylinop/wip/linalg/khatri_rao.py
--rw-r--r--  2.0 unx     4667 b- defN 24-Feb-16 11:07 lazylinop/wip/linalg/logm.py
--rw-r--r--  2.0 unx     4694 b- defN 24-Feb-16 11:07 lazylinop/wip/linalg/sinhm.py
--rw-r--r--  2.0 unx     2887 b- defN 24-Feb-16 11:07 lazylinop/wip/linalg/sinm.py
--rw-r--r--  2.0 unx     1582 b- defN 24-Feb-16 11:07 lazylinop/wip/linalg/spectral_norm.py
--rw-r--r--  2.0 unx     3754 b- defN 24-Feb-16 11:07 lazylinop/wip/linalg/sqrtm.py
--rw-r--r--  2.0 unx      253 b- defN 24-Feb-16 11:07 lazylinop/wip/parallel/__init__.py
--rw-r--r--  2.0 unx     8324 b- defN 24-Feb-16 11:07 lazylinop/wip/parallel/mpilop.py
--rw-r--r--  2.0 unx     4897 b- defN 24-Feb-16 11:07 lazylinop/wip/parallel/pmatmat.py
--rw-r--r--  2.0 unx     4250 b- defN 24-Feb-16 11:07 lazylinop/wip/parallel/pmatmat_mpi.py
--rw-r--r--  2.0 unx     5902 b- defN 24-Feb-16 11:07 lazylinop/wip/parallel/pmatmat_process.py
--rw-r--r--  2.0 unx     3306 b- defN 24-Feb-16 11:07 lazylinop/wip/parallel/pmatmat_thread.py
--rw-r--r--  2.0 unx     1434 b- defN 24-Feb-16 11:07 lazylinop-1.6.1.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx     5700 b- defN 24-Feb-16 11:07 lazylinop-1.6.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Feb-16 11:07 lazylinop-1.6.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 24-Feb-16 11:07 lazylinop-1.6.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3418 b- defN 24-Feb-16 11:07 lazylinop-1.6.1.dist-info/RECORD
-40 files, 418197 bytes uncompressed, 91494 bytes compressed:  78.1%
+Zip file size: 105410 bytes, number of entries: 42
+-rw-r--r--  2.0 unx      126 b- defN 24-Apr-11 10:41 lazylinop/__init__.py
+-rw-r--r--  2.0 unx     8275 b- defN 24-Apr-11 10:41 lazylinop/check_op.py
+-rw-r--r--  2.0 unx    50965 b- defN 24-Apr-11 10:41 lazylinop/lazylinop.py
+-rw-r--r--  2.0 unx      370 b- defN 24-Apr-11 10:41 lazylinop/basicops/__init__.py
+-rw-r--r--  2.0 unx     1508 b- defN 24-Apr-11 10:41 lazylinop/basicops/add.py
+-rw-r--r--  2.0 unx     2255 b- defN 24-Apr-11 10:41 lazylinop/basicops/blockdiag.py
+-rw-r--r--  2.0 unx     1852 b- defN 24-Apr-11 10:41 lazylinop/basicops/cat.py
+-rw-r--r--  2.0 unx    11699 b- defN 24-Apr-11 10:41 lazylinop/basicops/diag.py
+-rw-r--r--  2.0 unx     3406 b- defN 24-Apr-11 10:41 lazylinop/basicops/eye.py
+-rw-r--r--  2.0 unx     3792 b- defN 24-Apr-11 10:41 lazylinop/basicops/kron.py
+-rw-r--r--  2.0 unx     2309 b- defN 24-Apr-11 10:41 lazylinop/basicops/ones.py
+-rw-r--r--  2.0 unx    31288 b- defN 24-Apr-11 10:41 lazylinop/basicops/pad.py
+-rw-r--r--  2.0 unx     1573 b- defN 24-Apr-11 10:41 lazylinop/basicops/zeros.py
+-rw-r--r--  2.0 unx       78 b- defN 24-Apr-11 10:41 lazylinop/wip/__init__.py
+-rw-r--r--  2.0 unx     1443 b- defN 24-Apr-11 10:41 lazylinop/wip/code_optimization.py
+-rw-r--r--  2.0 unx     1447 b- defN 24-Apr-11 10:41 lazylinop/wip/linear_algebra.py
+-rw-r--r--  2.0 unx    68835 b- defN 24-Apr-11 10:41 lazylinop/wip/polynomial.py
+-rw-r--r--  2.0 unx   133585 b- defN 24-Apr-11 10:41 lazylinop/wip/signal.py
+-rw-r--r--  2.0 unx    57938 b- defN 24-Apr-11 10:41 lazylinop/wip/special_matrices.py
+-rw-r--r--  2.0 unx      298 b- defN 24-Apr-11 10:41 lazylinop/wip/linalg/__init__.py
+-rw-r--r--  2.0 unx     4792 b- defN 24-Apr-11 10:41 lazylinop/wip/linalg/coshm.py
+-rw-r--r--  2.0 unx     2820 b- defN 24-Apr-11 10:41 lazylinop/wip/linalg/cosm.py
+-rw-r--r--  2.0 unx     4237 b- defN 24-Apr-11 10:41 lazylinop/wip/linalg/expm.py
+-rw-r--r--  2.0 unx     5587 b- defN 24-Apr-11 10:41 lazylinop/wip/linalg/khatri_rao.py
+-rw-r--r--  2.0 unx     4667 b- defN 24-Apr-11 10:41 lazylinop/wip/linalg/logm.py
+-rw-r--r--  2.0 unx     4694 b- defN 24-Apr-11 10:41 lazylinop/wip/linalg/sinhm.py
+-rw-r--r--  2.0 unx     2827 b- defN 24-Apr-11 10:41 lazylinop/wip/linalg/sinm.py
+-rw-r--r--  2.0 unx     1582 b- defN 24-Apr-11 10:41 lazylinop/wip/linalg/spectral_norm.py
+-rw-r--r--  2.0 unx     3754 b- defN 24-Apr-11 10:41 lazylinop/wip/linalg/sqrtm.py
+-rw-r--r--  2.0 unx      253 b- defN 24-Apr-11 10:41 lazylinop/wip/parallel/__init__.py
+-rw-r--r--  2.0 unx     8328 b- defN 24-Apr-11 10:41 lazylinop/wip/parallel/mpilop.py
+-rw-r--r--  2.0 unx     4897 b- defN 24-Apr-11 10:41 lazylinop/wip/parallel/pmatmat.py
+-rw-r--r--  2.0 unx     4250 b- defN 24-Apr-11 10:41 lazylinop/wip/parallel/pmatmat_mpi.py
+-rw-r--r--  2.0 unx     5902 b- defN 24-Apr-11 10:41 lazylinop/wip/parallel/pmatmat_process.py
+-rw-r--r--  2.0 unx     3306 b- defN 24-Apr-11 10:41 lazylinop/wip/parallel/pmatmat_thread.py
+-rw-r--r--  2.0 unx       23 b- defN 24-Apr-11 10:41 lazylinop/wip/random/__init__.py
+-rw-r--r--  2.0 unx     6721 b- defN 24-Apr-11 10:41 lazylinop/wip/random/rand.py
+-rw-r--r--  2.0 unx     1434 b- defN 24-Apr-11 10:41 lazylinop-1.7.0.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx     8199 b- defN 24-Apr-11 10:41 lazylinop-1.7.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-11 10:41 lazylinop-1.7.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 24-Apr-11 10:41 lazylinop-1.7.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3590 b- defN 24-Apr-11 10:41 lazylinop-1.7.0.dist-info/RECORD
+42 files, 465007 bytes uncompressed, 99686 bytes compressed:  78.6%
```

## zipnote {}

```diff
@@ -99,23 +99,29 @@
 
 Filename: lazylinop/wip/parallel/pmatmat_process.py
 Comment: 
 
 Filename: lazylinop/wip/parallel/pmatmat_thread.py
 Comment: 
 
-Filename: lazylinop-1.6.1.dist-info/LICENSE.txt
+Filename: lazylinop/wip/random/__init__.py
 Comment: 
 
-Filename: lazylinop-1.6.1.dist-info/METADATA
+Filename: lazylinop/wip/random/rand.py
 Comment: 
 
-Filename: lazylinop-1.6.1.dist-info/WHEEL
+Filename: lazylinop-1.7.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: lazylinop-1.6.1.dist-info/top_level.txt
+Filename: lazylinop-1.7.0.dist-info/METADATA
 Comment: 
 
-Filename: lazylinop-1.6.1.dist-info/RECORD
+Filename: lazylinop-1.7.0.dist-info/WHEEL
+Comment: 
+
+Filename: lazylinop-1.7.0.dist-info/top_level.txt
+Comment: 
+
+Filename: lazylinop-1.7.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## lazylinop/__init__.py

```diff
@@ -1,5 +1,5 @@
 from .check_op import check_op
 from . import lazylinop
 from .lazylinop import *
 from .basicops import *
-__version__ = '1.6.1'
+__version__ = '1.7.0'
```

## lazylinop/lazylinop.py

```diff
@@ -81,19 +81,19 @@
         .. admonition:: Auto-implemented operations
             :class: admonition note
 
             - If only ``matvec`` is defined and not ``matmat``, an
               automatic naive ``matmat`` will be defined upon the given
               ``matvec`` but note that it might be suboptimal (in which
               case a ``matmat`` is useful).
-            - No need to handle the multiplication by a :class:`LazyLinOp`
-              or a numpy array of ``ndim > 2`` because both of them are
-              auto-implemented. For the latter operation, it is computed as in
-              `numpy.__matmul__ <https://numpy.org/doc/stable/reference/
-              generated/numpy.matmul.html>`_.
+            - No need to provide the implementation of the multiplication by a
+              :class:`LazyLinOp`, or a numpy array with ``ndim > 2`` because
+              both of them are auto-implemented. For the latter operation,
+              it is computed as in `numpy.__matmul__ <https://numpy.org/
+              doc/stable/reference/generated/numpy.matmul.html>`_.
 
 
         Return:
             ``LazyLinOp``
 
         Example:
             >>> # In this example we create a LazyLinOp
@@ -352,24 +352,51 @@
         return scalar_op
 
     def _checkattr(self, attr):
         if self._root_obj is not None and not hasattr(self._root_obj, attr):
             raise TypeError(attr+' is not supported by the root object of this'
                             ' LazyLinOp')
 
-    def _index_lambda(lop, indices):
-        from scipy.sparse import eye as seye
+    def _slice_to_indices(self, s, axis):
+        start = s.start if s.start is not None else 0
+        stop = s.stop if s.stop is not None else self.shape[axis]
+        step = s.step if s.step is not None else 1
+        return np.arange(start, stop, step)
+
+    def _index_lambda(self, indices):
+        #        from scipy.sparse import eye as seye
+        from scipy.sparse import csr_matrix
+        # TODO: csc_matrix might be more efficient than csr_matrix in certain
+        # cases
 
         def s():
+            _indices = [None, None]
+            if isinstance(indices, slice):
+                _indices[0] = self._slice_to_indices(indices, 0)
+                _indices[1] = np.arange(self.shape[1])
+            else:
+                for i in range(2):
+                    s = indices[i]
+                    if isinstance(s, slice):
+                        _indices[i] = self._slice_to_indices(s, i)
+                    elif isinstance(s, int):
+                        _indices[i] = np.arange(s, s+1)
+                    else:
+                        _indices[i] = indices[i]
+            n0, n1 = len(_indices[0]), len(_indices[1])
             return (
                 LazyLinOp._create_from_op(
-                    seye(lop.shape[0], format='csr')[indices[0]])
-                @ lop
+                    # seye(self.shape[0], format='csr')[indices[0]])
+                    csr_matrix((np.ones(n0), (np.arange(n0), _indices[0])),
+                               shape=(n0, self.shape[0])))
+                @ self
                 @ LazyLinOp._create_from_op(
-                    seye(lop.shape[1], format='csr')[:, indices[1]])
+                    # seye(self.shape[1], format='csr')[:, _indices[1]])
+                    csr_matrix((np.ones(n1), (_indices[1], np.arange(n1))),
+                               shape=(self.shape[1], n1)))
             )
         return s
 
     @property
     def _shape(self):
         """
         The shape (``tuple[int, int]``) of the :class:`LazyLinOp`.
@@ -440,15 +467,22 @@
 
         Args:
             op: an object compatible with self for this binary operation.
 
         """
         self._checkattr('__add__')
         if not LazyLinOp.islazylinop(op):
-            op = LazyLinOp._create_from_op(op)
+            if np.isscalar(op):
+                from lazylinop import ones
+                if op == 0:
+                    return self
+                else:
+                    op = ones(self.shape) * op
+            else:
+                op = LazyLinOp._create_from_op(op)
         if op.shape != self.shape:
             raise ValueError('Dimensions must agree')
         lambdas = {'@': lambda o: self @ o + op @ o,
                    'H': lambda: self.H + op.H,
                    'T': lambda: self.T + op.T,
                    'slice': lambda indices:
                    self._slice(indices) + op._slice(indices)}
@@ -726,16 +760,19 @@
         Args:
             other: a scalar or a vector/array.
 
         .. seealso:: lazylinop.LazyLinOp.__matmul__)
         """
         self._checkattr('__mul__')
         if np.isscalar(other):
-            Dshape = (self.shape[1], self.shape[1])
-            new_op = self @ LazyLinOp._create_from_scalar(other, Dshape)
+            if other == 1:
+                new_op = self
+            else:
+                Dshape = (self.shape[1], self.shape[1])
+                new_op = self @ LazyLinOp._create_from_scalar(other, Dshape)
         else:
             new_op = self @ other
         return new_op
 
     def __rmul__(self, other):
         """
         Returns other * self.
@@ -1004,22 +1041,51 @@
             >>> +lM
             <10x12 LazyLinOp with dtype=float64>
         """
         return self
 
     def __pow__(self, n):
         """
-        Returns the :py:class:`LazyLinOp` for the n-th power of self.
+        Returns the :py:class:`LazyLinOp` for the n-th power of ``self``.
 
-        .. warning::
+        - ``L**n == L @ L @ ... @ L`` (n-1 multiplications).
 
-            self must be square or this operation raises an exception.
+        Raises:
+            The :py:class:`.LazyLinOp` is not square.
+
+        Example:
+            >>> from lazylinop import aslazylinop
+            >>> import numpy as np
+            >>> M = np.random.rand(10, 10)
+            >>> lM = aslazylinop(M)
+            >>> np.allclose((lM**2).toarray(), M @ M)
+            True
         """
-        from lazylinop.wip.polynomial import power
-        return power(self, n)
+        if n < 0:
+            raise ValueError("n must be > 0.")
+
+        if self.shape[0] != self.shape[1]:
+            raise Exception("The LazyLinOp is not square.")
+
+        if n == 0:
+            from . import eye
+            return eye(self.shape[0], n=self.shape[1], k=0)
+
+        def _matmat(L, n, x):
+            output = L @ x
+            if n > 1:
+                for n in range(1, n):
+                    output = L @ output
+            return output
+
+        return LazyLinOp(
+            shape=self.shape,
+            matmat=lambda x: _matmat(self, n, x),
+            rmatmat=lambda x: _matmat(self.H, n, x)
+        )
 
     @staticmethod
     def islazylinop(obj):
         """
         Returns ``True`` if ``obj`` is a ``LazyLinOp``, ``False`` otherwise.
         """
         return isinstance(obj, LazyLinOp)
@@ -1047,15 +1113,16 @@
             6. ``op @ X`` is equal to the horizontal concatenation of all
                ``op @ X[:, j]`` for j in {0, ..., ``X.shape[1]-1``}.
 
 
         .. warning:: This function has a computational cost of several
                      matrix products.
                      It shouldn't be used into an efficient implementation but
-                     only to test a :py:class:`.LazyLinOp` works properly.
+                     only to test a :py:class:`.LazyLinOp` implementation is
+                     valid.
 
         Args:
             op: (:py:class:`LazyLinOp`)
                 Operator to test.
 
         Example:
             >>> from numpy.random import rand
@@ -1090,37 +1157,35 @@
             if not np.allclose(AX[:, i], self @ X[:, i]):
                 raise Exception("Wrong operator matrix product")
 #        if not np.allclose(
 #                self @ X,
 #                np.hstack([(self @ X[:, i]).reshape(-1, 1)
 #                           for i in range(X.shape[1])])):
 #            raise Exception("Wrong operator matrix product")
-        # Dot test to check forward - adjoint consistency
-        if not np.allclose((self @ u).conj().T @ v, u.conj().T @ (self.H @ v)):
-            raise Exception("Operator and its adjoint do not match")
-        if (self.T @ Y).shape[0] != self.shape[1]:
-            raise Exception("Wrong operator transpose dimension"
-                            " (when multiplying an array)")
         if not np.allclose(AX @ Y.T.conj(), (Y @ AX.T.conj()).T.conj()):
             raise Exception("Wrong operator on (Y @ X.H @ self.H).H")
         del AX
         # Check operator transpose dimension
         AY = self.H @ Y
-        if AY.shape[0] != self.shape[1]:
+        if ((self.T @ Y).shape[0] != self.shape[1] or
+                AY.shape[0] != self.shape[1]):
             raise Exception("Wrong operator transpose dimension"
                             " (when multiplying an array)")
         # Check operator adjoint on matrix product
         for i in range(X.shape[1]):
             if not np.allclose(AY[:, i], self.H @ Y[:, i]):
                 raise Exception("Wrong operator adjoint on matrix product")
 #        if not np.allclose(self.H @ Y,
 #                           np.hstack([(self.H @ Y[:, i]).reshape(-1, 1)
 #                                      for i in range(X.shape[1])])):
 #             raise Exception("Wrong operator adjoint on matrix product")
         del AY
+        # Dot test to check forward - adjoint consistency
+        if not np.allclose((self @ u).conj().T @ v, u.conj().T @ (self.H @ v)):
+            raise Exception("Operator and its adjoint do not match")
 
 
 def binary_dtype(A_dtype, B_dtype):
     """
     Returns the "greatest" dtype in size between A_dtype and B_dtype.
     If one dtype is complex the returned dtype is too.
     """
@@ -1165,32 +1230,36 @@
     Returns ``True`` if ``obj`` is a ``LazyLinOp``, ``False`` otherwise.
     """
     return LazyLinOp.islazylinop(obj)
 
 
 def aslazylinop(op, shape=None):
     """
-    Creates a :class:`LazyLinOp` based on linear operator ``op``.
-
-    .. note::
-        ``op`` must support operations and attributes defined in the
-        :class:`LazyLinOp` class. Especially, an implementation of the
-        matrix multiplication ``@``.
-        Any operation not supported would raise an exception at evaluation
-        time.
+    Returns ``op`` as a :class:`LazyLinOp`.
 
     Args:
         op: (``object``)
-            The linear operator object used to create a :class:`LazyLinOp`.
-            (it could be a numpy array, a scipy matrix, or any compatible
-            linear operator).
+            May be of any type compatible with `scipy.sparse.linalg.
+            aslinearoperator <https://docs.scipy.org/doc/scipy/reference/
+            generated/scipy.sparse.linalg.aslinearoperator.html#scipy.sparse.
+            linalg.aslinearoperator>`_
+            (e.g. a ``numpy.ndarray``, a `scipy <https://docs.scipy.org/doc/
+            scipy/tutorial/linalg.html>`_ matrix, a `scipy.LinearOperator
+            <https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.
+            linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator>`_,
+            a `pyfaust.Faust <https://faustgrp.gitlabpages.inria.fr/faust/
+            last-doc/html/classpyfaust_1_1Faust.html>`_ object, …).
+
+            See the :class:`.LazyLinOp` documentation for additional
+            information.
+
         shape: (``tuple[int, int]``)
             The shape of the resulting :class:`LazyLinOp`.
             If ``None`` the function relies on ``op.shape``.
-            This argument allows to overidde ``op.shape`` if for any reason it
+            This argument allows to override ``op.shape`` if for any reason it
             is not well defined (see below, the example of
             ``pylops.Symmetrize`` defective shape).
 
 
     Returns:
         A :class:`LazyLinOp` instance based on ``op``.
 
@@ -1257,20 +1326,34 @@
         https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/classpyfaust_1_1Faust.html
 
     .. seealso::
         `pyfaust.rand
         <https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/namespacepyfaust.html#abceec3d0838435ceb3df1befd1e29acc>`_,
         `pylops.Symmetrize
         <https://pylops.readthedocs.io/en/latest/api/generated/pylops.Symmetrize.html>`_.
+        `scipy.sparse.linalg.aslinearoperator <https://docs.scipy.org/doc/
+        scipy/reference/generated/scipy.sparse.linalg.aslinearoperator.html
+        #scipy.sparse.linalg.aslinearoperator>`_
 
     """
     if islazylinop(op):
         return op
     return LazyLinOp._create_from_op(op, shape)
 
+
+def aslazylinops(*ops):
+    """
+    Returns the list of aslazylinop(ops[i]).
+
+    .. seealso::
+
+        :func:`.aslazylinop`
+    """
+    return [aslazylinop(op) for op in ops]
+
 # below are deprecated names
 
 
 def aslazylinearoperator(op, shape=None):
     from warnings import warn
     warn("aslazylinearoperator is a deprecated name and will disappear in a"
          " next version. Please use aslazylinop.")
```

## lazylinop/basicops/add.py

```diff
@@ -1,8 +1,8 @@
-from lazylinop import LazyLinOp
+from lazylinop import LazyLinOp, aslazylinops
 
 
 def add(*ops):
     r"""
     Returns a :class:`LazyLinOp` add of linear operators ``ops`` ($\sum_i
     ops[i]$).
 
@@ -11,42 +11,48 @@
             Operators to add up.
 
     Returns:
         The :class:`LazyLinOp` for the sum of ops.
 
     Example:
         >>> import numpy as np
-        >>> from lazylinop import add, aslazylinop
+        >>> import lazylinop as lz
+        >>> from lazylinop import aslazylinop
         >>> nt = 10
         >>> d = 8
         >>> v = np.random.rand(d)
         >>> terms = [np.ones((d, d)) for i in range(nt)]
         >>> # terms are all Fausts here
-        >>> ls = add(*terms) # ls is the LazyLinOp add of terms
+        >>> ls = lz.add(*terms) # ls is the LazyLinOp add of terms
         >>> np_sum = 0
         >>> for i in range(nt): np_sum += terms[i]
         >>> np.allclose(ls @ v, nt * np.ones((d, d)) @ v)
         True
+
+    .. seealso::
+        :func:`.aslazylinop`
     """
 
     def lAx(A, x):
         return A @ x
 
     def lAHx(A, x):
         return A.T.conj() @ x
 
-    for op in ops[1:]:
+    ops = aslazylinops(*ops)
+
+    for i, op in enumerate(ops[1:]):
         if op.shape != ops[0].shape:
             raise ValueError('Dimensions must agree')
 
     def matmat(x, lmul):
         Ps = [None for _ in range(len(ops))]
         n = len(ops)
         for i, A in enumerate(ops):
             Ps[i] = lmul(A, x)
         S = Ps[-1]
         for i in range(n-2, -1, -1):
             S = S + Ps[i]
         return S
 
     return LazyLinOp(ops[0].shape, matmat=lambda x: matmat(x, lAx),
-                        rmatmat=lambda x: matmat(x, lAHx))
+                     rmatmat=lambda x: matmat(x, lAHx))
```

## lazylinop/basicops/blockdiag.py

```diff
@@ -1,8 +1,8 @@
-from lazylinop import binary_dtype, LazyLinOp
+from lazylinop import binary_dtype, LazyLinOp, aslazylinops
 import numpy as np
 
 
 def block_diag(*ops):
     """
     Returns the block diagonal :class:`LazyLinOp` of operators ``ops``.
 
@@ -12,29 +12,33 @@
              compatible linear operators.
 
     Returns:
         The diagonal block :class:`LazyLinOp`.
 
     Example:
         >>> import numpy as np
-        >>> from lazylinop import block_diag, aslazylinop
+        >>> import lazylinop as lz
+        >>> from lazylinop import aslazylinop
         >>> import scipy
         >>> nt = 10
         >>> d = 64
         >>> v = np.random.rand(d)
         >>> terms = [np.random.rand(64, 64) for _ in range(10)]
-        >>> ls = block_diag(*terms) # ls is the block diagonal LazyLinOp
+        >>> ls = lz.block_diag(*terms) # ls is the block diagonal LazyLinOp
         >>> np.allclose(scipy.linalg.block_diag(*terms), ls.toarray())
         True
 
     .. seealso::
         `scipy.linalg.block_diag <https://docs.scipy.org/doc/scipy/reference/
-        generated/scipy.linalg.block_diag.html>`_
+        generated/scipy.linalg.block_diag.html>`_,
+        :func:`.aslazylinop`
     """
 
+    ops = aslazylinops(*ops)
+
     def lAx(A, x):
         return A @ x
 
     def lAHx(A, x):
         return A.T.conj() @ x
 
     roffsets = [0]
@@ -63,10 +67,10 @@
         for i in range(1, n):
             S = np.vstack((S, Ps[i]))
         if x_is_1d:
             S = S.ravel()
         return S
 
     return LazyLinOp((coffsets[-1], roffsets[-1]), matmat=lambda x:
-                        matmat(x, lAx, roffsets),
-                        rmatmat=lambda x: matmat(x, lAHx, coffsets),
-                        dtype=dtype)
+                     matmat(x, lAx, roffsets),
+                     rmatmat=lambda x: matmat(x, lAHx, coffsets),
+                     dtype=dtype)
```

## lazylinop/basicops/cat.py

```diff
@@ -1,8 +1,8 @@
-from lazylinop import islazylinop, aslazylinop
+from lazylinop import aslazylinop
 
 
 def hstack(ops):
     """
     Concatenates linear operators horizontally.
 
     Args:
@@ -10,33 +10,33 @@
             For any pair ``i, j < len(ops)``, ``ops[i].shape[0] ==
             ops[i].shape[0]``.
 
     Returns:
         A concatenation :class:`LazyLinOp`.
 
     Example:
-        >>> from lazylinop import hstack, ones, islazylinop
         >>> import numpy as np
+        >>> import lazylinop as lz
+        >>> from lazylinop import islazylinop
         >>> A = np.ones((10, 10))
-        >>> B = ones((10, 2))
-        >>> lcat = hstack((A, B))
+        >>> B = lz.ones((10, 2))
+        >>> lcat = lz.hstack((A, B))
         >>> islazylinop(lcat)
         True
         >>> np.allclose(lcat.toarray(), np.hstack((A, B.toarray())))
         True
 
     .. seealso::
 
-        :func:`vstack`
-        `numpy.hstack
+        :func:`vstack`,
+        `numpy.hstack,
         <https://numpy.org/doc/stable/reference/generated/numpy.hstack.html>`_
+        :func:`.aslazylinop`
     """
-    lop = ops[0]
-    if not islazylinop(lop):
-        lop = aslazylinop(ops[0])
+    lop = aslazylinop(ops[0])
     return lop.concatenate(*ops[1:], axis=1)
 
 
 def vstack(ops):
     """
     Concatenates linear operators horizontally.
 
@@ -45,27 +45,27 @@
             For any pair ``i, j < len(ops)``, ``ops[i].shape[1] ==
             ops[i].shape[1]``.
 
     Returns:
         A concatenation :class:`LazyLinOp`.
 
     Example:
-        >>> from lazylinop import vstack, ones, islazylinop
         >>> import numpy as np
+        >>> import lazylinop as lz
+        >>> from lazylinop import islazylinop
         >>> A = np.ones((10, 10))
-        >>> B = ones((2, 10))
-        >>> lcat = vstack((A, B))
+        >>> B = lz.ones((2, 10))
+        >>> lcat = lz.vstack((A, B))
         >>> islazylinop(lcat)
         True
         >>> np.allclose(lcat.toarray(), np.vstack((A, B.toarray())))
         True
 
     .. seealso::
         :func:`hstack`
-        `numpy.hstack
-        <https://numpy.org/doc/stable/reference/generated/numpy.hstack.html>`_
+        `numpy.vstack
+        <https://numpy.org/doc/stable/reference/generated/numpy.vstack.html>`_
+        :func:`.aslazylinop`
 
     """
-    lop = ops[0]
-    if not islazylinop(lop):
-        lop = aslazylinop(ops[0])
+    lop = aslazylinop(ops[0])
     return lop.concatenate(*ops[1:], axis=0)
```

## lazylinop/basicops/diag.py

```diff
@@ -1,89 +1,145 @@
-from lazylinop import LazyLinOp
+from lazylinop import LazyLinOp, sanitize_op, aslazylinop
 import numpy as np
+from scipy.sparse import issparse, spdiags
 
 
-def diag(v, k=0):
-    """
+def diag(v, k=0, extract_meth='canonical_vectors', extract_batch=1):
+    r"""
     Extracts a diagonal or constructs a diagonal :py:class:`LazyLinOp`.
 
     Args:
-        v: (linear operator or a vector numpy array)
-            - If ``v`` is a :py:class:`LazyLinOp` or any object with a
-              :py:func:`toarray` function, returns a copy of its k-th diagonal.
-            - If ``v`` is a 1D numpy array, returns a :py:class:`LazyLinOp` with
-              ``v`` on the k-th diagonal.
+        v: (compatible linear operator,  1D ``numpy.ndarray``)
+            - If ``v`` is a :py:class:`LazyLinOp` or an array-like compatible
+              object, returns a copy of its k-th diagonal.
+            - If ``v`` is a 1D numpy array, returns a :py:class:`LazyLinOp`
+              with ``v`` on the k-th diagonal.
         k: (``int``)
-             the index of diagonal, 0 for the main diagonal,
+             The index of diagonal, ``0`` for the main diagonal,
              ``k > 0`` for diagonals above,
              ``k < 0`` for diagonals below (see :py:func:`eye`).
+        extract_meth: (``str``)
+            The method used to extract the diagonal vector. The interest to
+            have several methods resides in their difference of memory and
+            execution time costs but also on the operator capabilities (e.g.
+            not all of them support a CSC matrix as multiplication operand).
+
+            - ``'canonical_vectors'``: use canonical basis vectors $e_i$
+              to extract each diagonal element of the operator. It takes an
+              operator-vector multiplication to extract each diagonal element.
+            - ``'canonical_vectors_csc'``: The same as above but using scipy
+              `CSC matrices
+              <https://docs.scipy.org/doc/scipy/reference/generated/
+              scipy.sparse.csc_matrix.html#scipy.sparse.csc_matrix>`_
+              to encode the canonical vectors. The memory cost is
+              even smaller than that of ``'canonical_vectors'``.
+              However ``v`` must be compatible to CSC matrices multiplication.
+            - ``'slicing'``: extract diagonal elements by slicing rows and
+              columns by blocks of shape ``(extract_batch, extract_batch)``.
+            - ``'toarray'``: use :func:`LazyLinOp.toarray` to extract
+              the diagonal after a conversion to a whole numpy array.
+        extract_batch: (``int``)
+            - The size of the batch used for partial diagonal extraction in
+              ``'canonical_vectors'``, ``'canonical_vectors_csc'`` and
+              ``'slicing '`` methods.
+               This argument is ignored for ``'toarray'`` method.
+
+
+        .. admonition:: Diagonal extraction cost
+            :class: admonition warning
+
+            Even though the ``'toarray'`` method is generally faster if the
+            operator is not extremely large it has an important memory cost
+            ($O(v.shape[0] \times v.shape[1])$) .
+            Hence the default method is ``canonical_vectors`` in order to
+            avoid memory consumption.
+            However note that this method allows to define a memory-time
+            trade-off with the ``extract_batch`` argument. The larger is the
+            batch, the faster should be the execution (provided enough memory
+            is available).
 
     Returns:
         The extracted diagonal numpy vector or
         the constructed diagonal :py:class:`LazyLinOp`.
 
     Example: (diagonal :py:class:`LazyLinOp`)
-        >>> from lazylinop import diag
+        >>> import lazylinop as lz
         >>> import numpy as np
         >>> v = np.arange(1, 6)
         >>> v
         array([1, 2, 3, 4, 5])
-        >>> ld1 = diag(v)
+        >>> ld1 = lz.diag(v)
         >>> ld1
         <5x5 LazyLinOp with dtype=int64>
         >>> ld1.toarray()
         array([[1, 0, 0, 0, 0],
                [0, 2, 0, 0, 0],
                [0, 0, 3, 0, 0],
                [0, 0, 0, 4, 0],
                [0, 0, 0, 0, 5]])
-        >>> ld2 = diag(v, -2)
+        >>> ld2 = lz.diag(v, -2)
         >>> ld2
         <7x7 LazyLinOp with dtype=int64>
         >>> ld2.toarray()
         array([[0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0],
                [0, 2, 0, 0, 0, 0, 0],
                [0, 0, 3, 0, 0, 0, 0],
                [0, 0, 0, 4, 0, 0, 0],
                [0, 0, 0, 0, 5, 0, 0]])
-        >>> ld3 = diag(v, 2)
+        >>> ld3 = lz.diag(v, 2)
         >>> ld3
         <7x7 LazyLinOp with dtype=int64>
         >>> ld3.toarray()
         array([[0, 0, 1, 0, 0, 0, 0],
                [0, 0, 0, 2, 0, 0, 0],
                [0, 0, 0, 0, 3, 0, 0],
                [0, 0, 0, 0, 0, 4, 0],
                [0, 0, 0, 0, 0, 0, 5],
                [0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0]])
 
     Example: (diagonal extraction)
-        >>> from lazylinop import diag, aslazylinop
+        >>> import lazylinop as lz
+        >>> from lazylinop import aslazylinop
         >>> import numpy as np
         >>> lD = aslazylinop(np.random.rand(10, 12))
-        >>> d = diag(lD, -2)
+        >>> d = lz.diag(lD, -2)
         >>> # verify d is really the diagonal of index -2
         >>> d_ = np.array([lD[i, i-2] for i in range(abs(-2), lD.shape[0])])
         >>> np.allclose(d, d_)
         True
 
 
     .. seealso::
         `numpy.diag
         <https://numpy.org/doc/stable/reference/generated/numpy.diag.html>`_
+        :func:`.aslazylinop`
     """
+    if np.isscalar(extract_batch):
+        extract_batch = int(extract_batch)
+    if not isinstance(extract_batch, int) or extract_batch < 1:
+        raise TypeError('extract_batch must be a strictly positive int')
     te = TypeError("v must be a 1-dim vector (np.ndarray) or a 2d "
                    "array/LinearOperator.")
     if isinstance(v, np.ndarray) and v.ndim == 1:
+        # building diagonal op
         m = v.size + abs(k)
+        # spd is just in case x is sparse in matmat
+        if k > 0:
+            spd = spdiags([np.hstack((np.zeros(k), v))], k, m=m, n=m)
+        else:
+            spd = spdiags([v], k, m=m, n=m)
 
         def matmat(x, v, k):
+            if issparse(x):
+                # because elementwise mul for scipy sparse
+                # matrix is not immediate
+                return spd @ x
             v = v.reshape(v.size, 1)
             if len(x.shape) == 1:
                 x_is_1d = True
                 x = x.reshape(x.size, 1)
             else:
                 x_is_1d = False
             if k > 0:
@@ -95,18 +151,142 @@
                                y))
             else:  # k == 0
                 y = v * x[:v.size]
             if x_is_1d:
                 y = y.ravel()
             return y
         return LazyLinOp((m, m), matmat=lambda x: matmat(x, v, k),
-                            rmatmat=lambda x: matmat(x, np.conj(v), -k),
-                            dtype=v.dtype)
+                         rmatmat=lambda x: matmat(x, np.conj(v), -k),
+                         dtype=v.dtype)
     elif v.ndim == 2:
-        if isinstance(v, np.ndarray):
-            return np.diag(v, k=k)
-        elif hasattr(v, "toarray"):
-            return np.diag(v.toarray(), k)
+        # extraction of op diagonal
+        op = v
+        sanitize_op(op)
+        op = aslazylinop(op)
+
+        if extract_meth == 'toarray' or isinstance(op, np.ndarray):
+            return _extract_by_toarray(op, k, te)
+        elif extract_meth == 'slicing':
+            return _extract_by_slicing(op, *_prepare_extract(op, k),
+                                       extract_batch)
+        elif extract_meth == 'canonical_vectors':
+            return _extract_by_canonical_vecs(op, *_prepare_extract(op, k),
+                                              extract_batch)
+        elif extract_meth == 'canonical_vectors_csc':
+            return _extract_by_canonical_csc_vecs(op, *_prepare_extract(op, k),
+                                                  extract_batch)
+        elif extract_meth == 'canonical_vectors_csr':
+            return _extract_by_canonical_csr_vecs(op, *_prepare_extract(op, k),
+                                                  extract_batch)
         else:
-            raise te
-    else:  # v is 1-dim but not a numpy array
+            raise ValueError('Extraction method '+str(extract_meth)+' is'
+                             ' unknown.')
+    else:  # v is 1-dim but not a numpy array or more than 2-dim
         raise te
+
+
+def _batched_extract_inds_iterator(op, start_i, start_j, dlen, batch_sz):
+    i, j = start_i, start_j
+    for di in range(0, dlen, batch_sz):
+        next_di = min(dlen, di + batch_sz)
+        next_j = min(op.shape[1], j + batch_sz)
+        next_i = min(op.shape[0], i + batch_sz)
+        # e_batch_sz <= batch_sz
+        # is the effective batch size (because batch_sz might not divide
+        # op.shape[1] evenly, then e_batch_sz == op.shape[1] % batch_sz
+        e_batch_sz = next_j - j
+        yield (di, i, j, next_di, next_i, next_j, e_batch_sz)
+        i = next_i
+        j = next_j
+
+
+def _extract_by_slicing(op, d, start_i, start_j, dlen, batch_sz):
+    for di, i, j, next_di, next_i, next_j, _ in _batched_extract_inds_iterator(
+            op, start_i,
+            start_j, dlen,
+            batch_sz):
+        d[di:next_di] = np.diag(op[i:next_i, j:next_j].toarray())
+    return d
+
+
+def _extract_by_canonical_vecs(op, d, start_i, start_j, dlen, batch_sz):
+    ej = np.zeros((op.shape[1], batch_sz))
+    for di, i, j, next_di, next_i, next_j, e_batch_sz in (
+        _batched_extract_inds_iterator(
+            op, start_i,
+            start_j, dlen,
+            batch_sz)):
+        # use batch_sz canonical vectors for batch columns extraction
+        for jj in range(j, next_j):
+            ej[jj, jj-j] = 1
+        # extract blocks (columns then rows)
+        # and finally the diagonal of the block
+        # (ej[:, :e_batch_sz] is a group of e_batch_sz canonical vectors)
+        d[di:next_di] = np.diag((op @ ej[:, :e_batch_sz])[i:next_i])
+        if next_di != dlen:
+            # erase ones for next batch
+            for jj in range(j, next_j):
+                ej[jj, jj-j] = 0
+    return d
+
+
+def _extract_by_canonical_csc_vecs(op, d, start_i, start_j, dlen, batch_sz):
+    return _extract_by_canonical_sparse_vecs(op, d, start_i, start_j, dlen,
+                                             batch_sz, 'csc')
+
+
+def _extract_by_canonical_sparse_vecs(op, d, start_i, start_j, dlen, batch_sz,
+                                      scipy_format='csc'):
+    from scipy.sparse import csc_matrix, csr_matrix
+
+    def init_scipy_mat(fmt, *args, **kwargs):
+        assert fmt.lower() in ['csc', 'csr']
+        if fmt.lower() == 'csc':
+            return csc_matrix(*args, **kwargs)
+        else:  # fmt.lower() == 'csr':
+            return csr_matrix(*args, **kwargs)
+    ones = [1 for j in range(batch_sz)]
+    for di, i, j, next_di, next_i, next_j, e_batch_sz in (
+        _batched_extract_inds_iterator(
+            op, start_i,
+            start_j, dlen,
+            batch_sz)):
+        ej_ones_rows = np.arange(j, next_j)
+        ej_ones_cols = np.arange(0, e_batch_sz)
+        ej_data = ones[:e_batch_sz]
+        # ej is a group of e_batch_sz canonical vectors
+        ej = init_scipy_mat(scipy_format, (ej_data,
+                                           (ej_ones_rows,
+                                            ej_ones_cols)),
+                            shape=(op.shape[1], e_batch_sz))
+        res = (op @ ej)[i:next_i]
+        d[di:next_di] = (np.diag(res.toarray()) if issparse(res) else
+                         np.diag(res))
+    return d
+
+
+def _extract_by_canonical_csr_vecs(op, d, start_i, start_j, dlen, batch_sz):
+
+    return _extract_by_canonical_sparse_vecs(op, d, start_i, start_j, dlen,
+                                             batch_sz, 'csr')
+
+
+def _extract_by_toarray(op, k, te):
+    # op is a LazyLinOp because aslazylinop
+    # was called in diag
+    return np.diag(op.toarray(), k)
+
+
+def _start_row_col(k):
+    if k >= 0:
+        return 0, k
+    else:
+        return -k, 0
+
+
+def _prepare_extract(op, k):
+    if k >= op.shape[1] or k <= - op.shape[0]:
+        raise ValueError('k is out of bounds.')
+    i, j = _start_row_col(k)
+    dlen = min(op.shape[0] - i, op.shape[1] - j)
+    d = np.empty(dlen, dtype=op.dtype)
+    return d, i, j, dlen
```

## lazylinop/basicops/eye.py

```diff
@@ -19,43 +19,43 @@
              - negative integer for a diagonal below the main diagonal,
              - strictly positive integer for a diagonal above.
 
         dtype: (``str``)
             Data type of the :class:`LazyLinOp`.
 
     Example:
-        >>> from lazylinop import eye
-        >>> le1 = eye(5)
+        >>> import lazylinop as lz
+        >>> le1 = lz.eye(5)
         >>> le1
         <5x5 LazyLinOp with dtype=float64>
         >>> le1.toarray()
         array([[1., 0., 0., 0., 0.],
                [0., 1., 0., 0., 0.],
                [0., 0., 1., 0., 0.],
                [0., 0., 0., 1., 0.],
                [0., 0., 0., 0., 1.]])
-        >>> le2 = eye(5, 2)
+        >>> le2 = lz.eye(5, 2)
         >>> le2
         <5x2 LazyLinOp with dtype=float64>
         >>> le2.toarray()
         array([[1., 0.],
                [0., 1.],
                [0., 0.],
                [0., 0.],
                [0., 0.]])
-        >>> le3 = eye(5, 3, 1)
+        >>> le3 = lz.eye(5, 3, 1)
         >>> le3
         <5x3 LazyLinOp with dtype=float64>
         >>> le3.toarray()
         array([[0., 1., 0.],
                [0., 0., 1.],
                [0., 0., 0.],
                [0., 0., 0.],
                [0., 0., 0.]])
-        >>> le4 = eye(5, 3, -1)
+        >>> le4 = lz.eye(5, 3, -1)
         >>> le4
         <5x3 LazyLinOp with dtype=float64>
         >>> le4.toarray()
         array([[0., 0., 0.],
                [1., 0., 0.],
                [0., 1., 0.],
                [0., 0., 1.],
@@ -102,9 +102,9 @@
             t = (mul, z)
             mul = _vstack(t)
         if x_1dim:
             mul = mul.reshape(-1)
         return mul.astype(out_dtype)
     n = n if n is not None else m
     return LazyLinOp((m, n), matmat=lambda x: matmat(x, m, n, k),
-                        rmatmat=lambda x: matmat(x, n, m, -k),
-                        dtype=dtype)
+                     rmatmat=lambda x: matmat(x, n, m, -k),
+                     dtype=dtype)
```

## lazylinop/basicops/kron.py

```diff
@@ -1,99 +1,104 @@
-from lazylinop import LazyLinOp, binary_dtype
+from lazylinop import LazyLinOp, binary_dtype, aslazylinops
 import numpy as np
 
 
-def kron(A, B):
+def kron(op1, op2):
     r"""
-    Returns the :class:`LazyLinOp` for the Kronecker product $A \otimes B$.
+    Returns the :class:`LazyLinOp` for the Kronecker product $op1 \otimes op2$.
 
     .. note::
         This specialization is particularly optimized for multiplying the
         operator by a vector.
 
     Args:
-        A: (compatible linear operator)
+        op1: (compatible linear operator)
             scaling factor,
-        B: (compatible linear operator)
+        op2: (compatible linear operator)
             block factor.
 
     Returns:
         The Kronecker product :class:`LazyLinOp`.
 
     Example:
-        >>> from lazylinop import kron as lkron
         >>> import numpy as np
+        >>> import lazylinop as lz
         >>> from pyfaust import rand
-        >>> A = np.random.rand(100, 100)
-        >>> B = np.random.rand(100, 100)
-        >>> AxB = np.kron(A,B)
-        >>> lAxB = lkron(A, B)
+        >>> op1 = np.random.rand(100, 100)
+        >>> op2 = np.random.rand(100, 100)
+        >>> AxB = np.kron(op1,op2)
+        >>> lAxB = lz.kron(op1, op2)
         >>> x = np.random.rand(AxB.shape[1], 1)
         >>> print(np.allclose(AxB@x, lAxB@x))
         True
         >>> from timeit import timeit
         >>> timeit(lambda: AxB @ x, number=10) # doctest:+ELLIPSIS
         0...
         >>> # example: 0.4692082800902426
         >>> timeit(lambda: lAxB @ x, number=10) # doctest:+ELLIPSIS
         0...
         >>> # example 0.03464869409799576
 
     .. seealso::
-        numpy.kron_,
-        scipy.sparse.kron_,
-        pylops.Kronecker_
+        - numpy.kron_,
+        - scipy.sparse.kron_,
+        - pylops.Kronecker_,
+        - :func:`.aslazylinop`,
+        - `Kronecker product on Wikipedia
+          <https://en.wikipedia.org/wiki/Kronecker_product>`_.
 
 .. _numpy.kron:
     https://numpy.org/doc/stable/reference/generated/numpy.kron.html
 .. _scipy.sparse.kron:
     https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.kron.html
 .. _pylops.Kronecker:
     https://pylops.readthedocs.io/en/stable/api/generated/pylops.Kronecker.html
     """
-    def _kron(A, B, shape, op):
+    op1, op2 = aslazylinops(op1, op2)
+
+    def _kron(op1, op2, shape, op):
 
         if isinstance(op, np.ndarray):
             op = np.asfortranarray(op)
 
         if (hasattr(op, 'reshape') and
            hasattr(op, '__matmul__') and hasattr(op, '__getitem__')):
 
             if len(op.shape) == 1:
                 op = op.reshape((op.size, 1))
                 one_dim = True
             else:
                 one_dim = False
-            dtype = binary_dtype(binary_dtype(A.dtype, B.dtype), op.dtype)
+            dtype = binary_dtype(binary_dtype(op1.dtype, op2.dtype), op.dtype)
             res = np.empty((shape[0], op.shape[1]), dtype=dtype)
 
             def out_col(j, ncols):
                 for j in range(j, min(j + ncols, op.shape[1])):
-                    op_mat = op[:, j].reshape((A.shape[1], B.shape[1]))
+                    op_mat = op[:, j].reshape((op1.shape[1], op2.shape[1]))
                     # Do we multiply from left to right or from right to left?
-                    m, k = A.shape
+                    m, k = op1.shape
                     k, n = op_mat.shape
-                    n, p = B.T.shape
+                    n, p = op2.T.shape
                     ltor = m * k * n + m * n * p
                     rtol = m * k * p + k * n * p
                     if ltor < rtol:
-                        res[:, j] = ((A @ op_mat) @ B.T).reshape(shape[0])
+                        res[:, j] = ((op1 @ op_mat) @ op2.T).reshape(shape[0])
                     else:
-                        res[:, j] = (A @ (op_mat @ B.T)).reshape(shape[0])
+                        res[:, j] = (op1 @ (op_mat @ op2.T)).reshape(shape[0])
 
             ncols = op.shape[1]
             out_col(0, ncols)
             if one_dim:
                 res = res.ravel()
         else:
             raise TypeError('op must possess reshape, __matmul__ and'
                             ' __getitem__ attributes to be multiplied by a'
                             ' Kronecker LazyLinOp (use toarray on the'
                             ' latter to multiply by the former)')
         return res
 
-    shape = (A.shape[0] * B.shape[0], A.shape[1] * B.shape[1])
+    shape = (op1.shape[0] * op2.shape[0], op1.shape[1] * op2.shape[1])
     return LazyLinOp(shape,
-                        matmat=lambda x: _kron(A, B, shape, x),
-                        rmatmat=lambda x: _kron(A.T.conj(), B.T.conj(),
-                                                (shape[1], shape[0]), x),
-                        dtype=binary_dtype(A.dtype, B.dtype))
+                     matmat=lambda x: _kron(op1, op2, shape, x),
+                     rmatmat=lambda x: _kron(op1.T.conj(), op2.T.conj(),
+                                             (shape[1], shape[0]), x),
+                     dtype=binary_dtype(op1.dtype, op2.dtype))
```

## lazylinop/basicops/ones.py

```diff
@@ -4,34 +4,34 @@
 
 
 def ones(shape: tuple[int, int],
          dtype: Union[str, None] = None):
     """
     Returns a :class:`LazyLinOp` ones.
 
-    .. admonition:: Free memory cost
+    .. admonition:: Fixed memory cost
         :class: admonition note
 
-        Whatever is the shape of the ``ones``, it has no memory cost.
+        Whatever is the shape of the ``ones``, it has the same memory cost.
 
     Args:
 
         shape: (``tuple[int, int]``)
             Operator shape, e.g., ``(2, 3)``.
 
         dtype: (``str``)
             numpy dtype ``str`` (e.g. ``'float64'``).
 
     Returns:
         :class:`LazyLinOp` ones.
 
     Example:
-        >>> from lazylinop import ones
-        >>> Lo = ones((6, 5), dtype='float')
         >>> import numpy as np
+        >>> import lazylinop as lz
+        >>> Lo = lz.ones((6, 5), dtype='float')
         >>> v = np.arange(5)
         >>> Lo @ v
         array([10., 10., 10., 10., 10., 10.])
         >>> Oa = np.ones((6, 5))
         >>> Oa @ v
         array([10., 10., 10., 10., 10., 10.])
         >>> M = np.arange(5*4).reshape(5, 4)
@@ -76,9 +76,9 @@
 
         if op.ndim == 1:
             return ret.ravel()
         else:
             return ret
 
     return LazyLinOp((m, n), matmat=lambda x: mul(m, n, x),
-                        rmatmat=lambda x: mul(n, m, x),
-                        dtype=dtype)
+                     rmatmat=lambda x: mul(n, m, x),
+                     dtype=dtype)
```

## lazylinop/basicops/pad.py

```diff
@@ -1,46 +1,48 @@
 import numpy as np
 from lazylinop import LazyLinOp, aslazylinop
 from lazylinop.basicops import hstack, vstack, eye, kron
-from scipy.sparse import issparse
 from warnings import warn
 
 
-def pad(X, pad_width, constant_values=0):
+def pad(op, pad_width, constant_values=0):
     """
-    Returns a :py:class:`LazyLinOp` of the padded ``X``.
+    Returns a :py:class:`LazyLinOp` of the padded ``op``.
 
     Args:
-        X: (``scipy LinearOperator``, ``LazyLinOperator``, ``numpy array``)
-            The operator/array/vector to pad.
+        op: (``scipy LinearOperator``, ``LazyLinOperator``, ``numpy array``)
+            The operator/array to pad.
+
         pad_width: (``tuple``, ``list``)
-            Number (``int``) of values padded to the edges of each axis.
+            Number of values padded to the edges of each axis.
+
+            - ``((B0, A0), (B1, A1))`` (See Figure `Padding format`).
+            - ``(B0, A0)`` is equivalent to ``((B0, A0), (0, 0))``.
 
-            - ``(B0, A0)`` if ``X`` is one-dimensional (B for before,
-              A for after).
-            - ``((B0, A0), (B1, A1))`` if ``X`` is two-dimensional.
-            See Figure `Padding format`.
         constant_values: (``tuple``, ``list``, ``scalar``)
-            ``((VB0, VA0)``, ``(VB1, VA1))``, or ``((VB0, VA0))`` or
-            ``(V,)`` or ``V``: padding values before (``VBi``) and values after
-            (``VAi``) on each dimension. In Figure `Padding format` value
-            ``VBi`` (resp. ``VAi``) goes where padding width ``Bi`` (resp.
-            ``Ai``) is.
-
-            - If not enough values ``VBi = VAi``.
-            - If values are missing for the second dimension, same values as
-              for the first dimension are used.
+            The values to set the padded values for each axis.
+
+            - ``((VB0, VA0)``, ``(VB1, VA1))``: padding values before (``VBi``)
+              and values after (``VAi``) on each dimension.
+              In Figure `Padding format` value ``VBi`` (resp. ``VAi``) goes
+              where padding width ``Bi`` (resp.  ``Ai``) is.
+            - ``((VB0, VA0))`` is equivalent to ``((VB0, VA0), (VB0, VA0))``.
+            - ``(V,)`` or ``V`` is equivalent to ``((V, V), (V, V))``.
+            - ``((VB0,), (VB1,))`` is equivalent to
+              ``((VB0, VB0), (VB1, VB1))``.
 
     .. _padding_format
-    Padding format (on a vector ``v`` and a matrix ``M``)
+    Padding format (for an operator ``op``)
     --------------
         .. image:: _static/pad_width.svg
+            :width: 400px
+            :height: 400px
 
     Example:
-        >>> from lazylinop import pad
+        >>> import lazylinop as lz
         >>> from numpy import arange
         >>> A = arange(18*2).reshape((18, 2))
         >>> A
         array([[ 0,  1],
                [ 2,  3],
                [ 4,  5],
                [ 6,  7],
@@ -54,15 +56,15 @@
                [22, 23],
                [24, 25],
                [26, 27],
                [28, 29],
                [30, 31],
                [32, 33],
                [34, 35]])
-        >>> lpA = pad(A, (2, 3))
+        >>> lpA = lz.pad(A, (2, 3))
         >>> lpA
         <23x2 LazyLinOp with dtype=int64>
         >>> lpA.toarray()
         array([[ 0,  0],
                [ 0,  0],
                [ 0,  1],
                [ 2,  3],
@@ -81,15 +83,15 @@
                [28, 29],
                [30, 31],
                [32, 33],
                [34, 35],
                [ 0,  0],
                [ 0,  0],
                [ 0,  0]])
-        >>> lpA2 = pad(A, ((2, 3), (4, 1)))
+        >>> lpA2 = lz.pad(A, ((2, 3), (4, 1)))
         >>> lpA2
         <23x7 LazyLinOp with dtype=int64>
         >>> lpA2.toarray()
         array([[ 0,  0,  0,  0,  0,  0,  0],
                [ 0,  0,  0,  0,  0,  0,  0],
                [ 0,  0,  0,  0,  0,  1,  0],
                [ 0,  0,  0,  0,  2,  3,  0],
@@ -108,52 +110,84 @@
                [ 0,  0,  0,  0, 28, 29,  0],
                [ 0,  0,  0,  0, 30, 31,  0],
                [ 0,  0,  0,  0, 32, 33,  0],
                [ 0,  0,  0,  0, 34, 35,  0],
                [ 0,  0,  0,  0,  0,  0,  0],
                [ 0,  0,  0,  0,  0,  0,  0],
                [ 0,  0,  0,  0,  0,  0,  0]])
-        >>> # padding a vector
-        >>> x = np.full(3, 1)
-        >>> lpx = pad(x, (2, 3))
-        >>> lpx
-        <8x1 LazyLinOp with dtype=int64>
-        >>> lpx.toarray().ravel()
-        array([0, 0, 1, 1, 1, 0, 0, 0])
-        >>> lpx1 = pad(x, (2, 3), constant_values=(-1, 2))
-        >>> lpx1.toarray().ravel()
-        array([-1, -1,  1,  1,  1,  2,  2,  2])
+        >>> # the same with arbitrary values
+        >>> pw = ((2, 3), (4, 1))
+        >>> cv = ((-1, -2), (-3, (-4)))
+        >>> lpA3 = lz.pad(A, pw, constant_values=cv)
+        >>> lpA3
+        <23x7 LazyLinOp with dtype=int64>
+        >>> lpA3.toarray()
+        array([[-3, -3, -3, -3, -1, -1, -4],
+               [-3, -3, -3, -3, -1, -1, -4],
+               [-3, -3, -3, -3,  0,  1, -4],
+               [-3, -3, -3, -3,  2,  3, -4],
+               [-3, -3, -3, -3,  4,  5, -4],
+               [-3, -3, -3, -3,  6,  7, -4],
+               [-3, -3, -3, -3,  8,  9, -4],
+               [-3, -3, -3, -3, 10, 11, -4],
+               [-3, -3, -3, -3, 12, 13, -4],
+               [-3, -3, -3, -3, 14, 15, -4],
+               [-3, -3, -3, -3, 16, 17, -4],
+               [-3, -3, -3, -3, 18, 19, -4],
+               [-3, -3, -3, -3, 20, 21, -4],
+               [-3, -3, -3, -3, 22, 23, -4],
+               [-3, -3, -3, -3, 24, 25, -4],
+               [-3, -3, -3, -3, 26, 27, -4],
+               [-3, -3, -3, -3, 28, 29, -4],
+               [-3, -3, -3, -3, 30, 31, -4],
+               [-3, -3, -3, -3, 32, 33, -4],
+               [-3, -3, -3, -3, 34, 35, -4],
+               [-3, -3, -3, -3, -2, -2, -4],
+               [-3, -3, -3, -3, -2, -2, -4],
+               [-3, -3, -3, -3, -2, -2, -4]])
+
+
+
+        zero-padded DFT example:
+            >>> import lazylinop as lz
+            >>> from lazylinop.wip.signal import fft
+            >>> e = lz.eye(5)
+            >>> pe = lz.pad(e, (0, 3))
+            >>> pfft = fft(8) @ pe
 
 
         .. seealso::
             `numpy.pad <https://numpy.org/doc/stable/reference/generated/
-            numpy.pad.html>`_
+            numpy.pad.html>`_,
+            :func:`.aslazylinop`
         """
     if (len(pad_width) == 2 and
         isinstance(pad_width[0], (tuple, list)) and
             isinstance(pad_width[1], (tuple, list))):
-        op_shape = (X.shape[0] + np.sum(pad_width[0]), X.shape[1] +
+        op_shape = (op.shape[0] + np.sum(pad_width[0]), op.shape[1] +
                     np.sum(pad_width[1]))
     elif len(pad_width) == 2 and isinstance(pad_width, (tuple, list)):
-        if X.ndim == 1:
-            X = X.reshape(X.size, 1)
-        if X.ndim == 2:
-            op_shape = (X.shape[0] + np.sum(pad_width), X.shape[1])
+        if op.ndim == 1:
+            op = op.reshape(op.size, 1)
+        if op.ndim == 2:
+            op_shape = (op.shape[0] + np.sum(pad_width), op.shape[1])
             pad_width = (pad_width, (0, 0))
         else:
-            raise ValueError("X must be 1d or 2d dimensional only")
+            raise ValueError("op must be 1d or 2d dimensional only")
+        op = aslazylinop(op)
     else:
         raise ValueError('pad_width is not valid; (before, after) or'
                          ' ((before1, after1), (before2, after2))')
     return LazyLinOp(op_shape,
-                        matmat=lambda M: (ppadder(
-                            X.shape,
-                            pad_width,
-                            constant_values=constant_values) @ X) @ M,
-                        rmatmat=lambda M: X @ M, dtype=X.dtype)
+                     matmat=lambda M: (ppadder(
+                         op.shape,
+                         pad_width,
+                         mode='constant',
+                         constant_values=constant_values) @ op) @ M,
+                     rmatmat=lambda M: op @ M, dtype=op.dtype)
 
 
 def padder(X_shape, pad_width):
     """
     Returns a :py:class:`LazyLinOp` for row dimension zero padding of any X.
 
     The :py:class:`LazyLinOp` ``L`` returned is also able to unpad the
@@ -234,15 +268,15 @@
         >>> lz2.H @ (lz2 @ x)
         array([1., 1., 1.])
     """
     return ppadder(X_shape, (pad_width, (0, 0))
                    if len(X_shape) == 2 else pad_width)
 
 
-def ppadder(x_shape, pad_width, constant_values=0, **kwargs):
+def ppadder(x_shape, pad_width, mode='constant', constant_values=0, **kwargs):
     """
     Returns a :py:class:`LazyLinOp` for zero padding of any X.
 
     .. warning:: this is a permissive padder that allows to break the properly
     defined matrix product because it can pad such that the number of columns
     of input is not the same as output.
     It permits also to pad with nonzero constant values.
@@ -254,23 +288,25 @@
     Args:
         x_shape:
              shape of x to apply the padding to.
         pad_width:
              a tuple/list of tuples/pairs of integers. It can be one tuple only
              if x is one-dimensional or a tuple of two tuples if x
              two-dimensional.
+        mode:
+            see :py:func:`.pad`
         constant_values: one or two tuples of two scalars or scalar.
             ((before0, after0), (before1, after1)), or ((before0, after0)) or
             (constant,) or constant: values for padding before and after on
             each dimension. If not enough values before = after and in case of
             a missing value for a dimension then the same values are used for
             the two dimensions.
 
     Example:
-        >>> from lazylinop import pad
+        >>> from lazylinop.basicops import ppadder
         >>> from numpy import arange
         >>> A = arange(18*2).reshape((18, 2))
         >>> A
         array([[ 0,  1],
                [ 2,  3],
                [ 4,  5],
                [ 6,  7],
@@ -384,25 +420,25 @@
                [32, 33],
                [34, 35]])
         >>> # original A is retrieved
 
     See also `numpy.pad <https://numpy.org/doc/stable/reference/generated/
     numpy.pad.html>`_
     """
+    constant_values = _sanitize_contant_values(constant_values)
     pad_width = np.array(pad_width).astype('int')
     if pad_width.shape[0] > 2 or pad_width.ndim > 1 and pad_width.shape[1] > 2:
         raise ValueError('Cannot pad zeros on more than two dimensions')
     if len(x_shape) != pad_width.ndim:
         raise ValueError('pad_width number of tuples must be len(x_shape).')
     if pad_width.ndim == 1:
         pad_width_ndim_was_1 = True
         pad_width = np.vstack((pad_width, (0, 0)))
     else:
         pad_width_ndim_was_1 = False
-    constant_values = _sanitize_contant_values(constant_values)
     kron_handled_cv = [((0, 0), (0, 0))]
     x_size = np.prod(x_shape)
     x_is_vec = x_size == x_shape[0] or x_size == x_shape[1]
     if 'impl' not in kwargs or kwargs['impl'] != 'nokron':
         if ('impl' in kwargs and 'kron' == kwargs['impl'] or
             'impl' not in kwargs and
                 x_is_vec and constant_values in kron_handled_cv):
@@ -415,104 +451,95 @@
     lop_shape = (np.prod(np.sum(pad_width if len(x_shape) == 2 else
                                 pad_width[0], axis=0 if len(x_shape) == 1 else
                                 1) +
                          x_shape),
                  np.prod(x_shape))
 
     def mul(op):
+        # op can only be a np.ndarray or a scipy matrix (see LazyLinOp)
         op_reshaped = False
         if op.ndim == 1:
-            # op can't be a LazyLinOp
             if pad_width_ndim_was_1:
-                return np.pad(op, pad_width[0], mode="constant",
+                return np.pad(op, pad_width[0], mode=mode,
                               constant_values=constant_values[0])
             else:
                 op = op.reshape(x_shape)
                 op_reshaped = True
         elif x_shape == op.shape and isinstance(op, np.ndarray):
-            if (constant_values == ((0, 0), (0, 0)) and
+            if (mode == 'constant' and constant_values == ((0, 0), (0, 0)) and
                     all(pad_width[0] == (0, 0))):
                 # particular case opt. (zero padding of columns)
                 out = np.zeros((x_shape[0], x_shape[1] + np.sum(pad_width[1])))
                 out[:, pad_width[1][0]:pad_width[1][0]+op.shape[1]] = op
                 return out
             else:
-                return np.pad(op, pad_width, mode='constant',
+                return np.pad(op, pad_width, mode=mode,
                               constant_values=constant_values)
         elif x_shape != op.shape:
             out = aslazylinop(np.empty((lop_shape[0], 0)))
             for j in range(op.shape[1]):
                 out_v = mul(op[:, j])
                 if out_v.ndim == 1:
                     out_v = out_v.reshape((out_v.size, 1))
                 out = hstack((out, out_v))
-            if isinstance(op, np.ndarray) or issparse(op):
-                return out.toarray()
-            else:
-                return out
+            return out.toarray()
         out = aslazylinop(op)
         for i in range(pad_width.shape[0]):
             bw = pad_width[i][0]
             aw = pad_width[i][1]
             bv = constant_values[i][0]
             av = constant_values[i][0]
             if bw > 0:
                 if i == 0:
                     out = vstack((_pad_block((bw, out.shape[1]), bv,
+                                             mode=mode, op=op,
                                              dtype=op.dtype), out))
                 else:  # i == 1:
                     out = hstack((_pad_block((out.shape[0], bw), bv,
+                                             mode=mode, op=op,
                                              dtype=op.dtype), out))
             if aw > 0:
                 if i == 0:
                     out = vstack((out, _pad_block((aw, out.shape[1]), av,
+                                                  mode=mode, op=op,
                                                   dtype=op.dtype)))
                 else:  # i == 1:
                     out = hstack((out, _pad_block((out.shape[0], aw), av,
+                                                  mode=mode, op=op,
                                                   dtype=op.dtype)))
-        if isinstance(op, np.ndarray) or issparse(op):
-            if op_reshaped:
-                return out.toarray().ravel()
-            else:
-                return out.toarray()
+        if op_reshaped:
+            return out.toarray().ravel()
         else:
-            return out
+            return out.toarray()
 
     def rmul(op):
-        op_reshaped = False
+        # op can only be a np.ndarray or a scipy matrix (see LazyLinOp)
         op_std_2d_shape = tuple(np.sum(pad_width, axis=len(pad_width) - 1) +
                                 x_shape)
         if op.ndim == 1:
             if pad_width_ndim_was_1:
-                # op can't be a LazyLinOp
                 return op[pad_width[0, 0]: pad_width[0, 0] + x_shape[0]]
             else:
                 op = op.reshape(op_std_2d_shape)
-                op_reshaped = True
+                r_offset = pad_width[0][0]
+                c_offset = pad_width[1][0]
+                out = op[r_offset:r_offset + x_shape[0],
+                         c_offset:c_offset + x_shape[1]]
+                return out.ravel()
         elif op_std_2d_shape != op.shape:
             out = aslazylinop(np.empty((lop_shape[1], 0)))
             for j in range(op.shape[1]):
                 out_v = rmul(op[:, j])
                 if out_v.ndim == 1:
                     out_v = out_v.reshape((out_v.size, 1))
                 out = hstack((out, out_v))
-            if isinstance(op, np.ndarray) or issparse(op):
-                return out.toarray()
-            else:
-                return out
-        r_offset = pad_width[0][0]
-        c_offset = pad_width[1][0]
-        out = op[r_offset:r_offset + x_shape[0],
-                 c_offset:c_offset + x_shape[1]]
-        if op_reshaped:
-            return out.ravel()
-        else:
-            return out
+            return out.toarray()
+
     ret = LazyLinOp(lop_shape, matmat=lambda op: mul(op), rmatmat=lambda
-                       op: rmul(op))
+                    op: rmul(op))
     ret.ravel_op = True  # a 2d array can be flatten to be compatible
     # to zpad.shape[1]
     return ret
 
 
 def zpad(x_shape, pad_width):
     """
@@ -521,54 +548,56 @@
     """
     warn("Don't use [DEPRECATED] zpad, use pad with default constant_values"
          " (zeros)")
     return ppadder(x_shape, pad_width, constant_values=0)
 
 
 def _sanitize_contant_values(constant_values):
-    # TODO: check all cases and remove possible unecessary code
-    if np.isscalar(constant_values):
-        constant_values = [constant_values, ]
+    if np.isscalar(constant_values) and np.isreal(constant_values):
+        constant_values = [int(constant_values), ]
     if isinstance(constant_values, (tuple, np.ndarray)):
         constant_values = list(constant_values)
     if not isinstance(constant_values, list):
         raise TypeError('Invalid constant_values')
     if len(constant_values) == 1:
         constant_values = [constant_values, constant_values]
     if np.isscalar(constant_values[0]) and np.isscalar(constant_values[1]):
         constant_values = [constant_values, constant_values]
     for i in range(2):
-        if np.isscalar(constant_values[i]):
-            constant_values[i] = [constant_values[i],
-                                  constant_values[i]]
         lc = len(constant_values[i])
         if lc == 1:
             constant_values[i] = [constant_values[i][0],
                                   constant_values[i][0]]
         elif lc != 2:
             raise ValueError('constant_values contain sequence of invalid size'
                              ' (valid sizes are 1 or 2)')
         for j in range(2):
-            if not np.isscalar(constant_values[i][j]):
+            if (not np.isscalar(constant_values[i][j]) or
+                    not np.isreal(constant_values[i][j])):
                 raise ValueError('constant_values contains something that is'
                                  ' not a scalar')
+        constant_values[i] = list((int(constant_values[i][0]),
+                                  int(constant_values[i][1])))
         # convert to tuple
         constant_values[i] = tuple(constant_values[i])
     return tuple(constant_values)
 
 
 sanitize_const_values = _sanitize_contant_values
 
+# TODO: _sanitize_pad_width
+
 
-def _pad_block(shape, v=0, dtype=None):
+def _pad_block(shape, v=0, op=None, mode='constant', dtype=None):
     from lazylinop.basicops import zeros, ones
-    if v == 0:
-        return zeros(shape, dtype=dtype)
-    else:
-        return ones(shape, dtype=dtype) * v
+    if mode == 'constant':
+        if v == 0:
+            return zeros(shape, dtype=dtype)
+        else:
+            return ones(shape, dtype=dtype) * v
 
 
 def kron_pad(shape: tuple, pad_width: tuple):
     """Constructs a lazy linear operator Op for padding.
 
     If shape is a tuple (X, Y), Op is applied to a 1d array of shape (X * Y, ).
     The output of the padding of the 2d input array is given by
@@ -598,31 +627,31 @@
             pad_width expects (A, B) or ((A, B), (C, D)).
         ValueError
             pad_width expects positive values.
         ValueError
             If len(shape) is 1, pad_width expects a tuple (A, B).
 
     Examples:
-        >>> from lazylinop.basicops.pad import kron_pad
+        >>> from lazylinop.basicops.pad import kron_pad as lz_kron_pad
         >>> x = np.arange(1, 4 + 1, 1).reshape(2, 2)
         >>> x
         array([[1, 2],
                [3, 4]])
-        >>> y = kron_pad(x.shape, (1, 2)) @ x.flatten()
+        >>> y = lz_kron_pad(x.shape, (1, 2)) @ x.flatten()
         >>> y.reshape(5, 5)
         array([[0, 0, 0, 0, 0],
                [0, 1, 2, 0, 0],
                [0, 3, 4, 0, 0],
                [0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0]])
         >>> x = np.arange(1, 6 + 1, 1).reshape(2, 3)
         >>> x
         array([[1, 2, 3],
                [4, 5, 6]])
-        >>> y = kron_pad(x.shape, ((2, 1), (2, 3))) @ x.flatten()
+        >>> y = lz_kron_pad(x.shape, ((2, 1), (2, 3))) @ x.flatten()
         >>> y.reshape(5, 8)
         array([[0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 1, 2, 3, 0, 0, 0],
                [0, 0, 4, 5, 6, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0]])
 
@@ -668,15 +697,15 @@
             M = eye(shape[0] + pad_width[0] + pad_width[1], n=shape[0],
                     k=-pad_width[0], dtype=dtype)
             NT = eye(shape[1] + pad_width[0] + pad_width[1], n=shape[1],
                      k=-pad_width[0], dtype=dtype)
             Op = kron(M, NT)
             return Op
     else:
-        pass
+        raise ValueError("shape must be 1d or 2d dimensional only")
 
 
 def mpad2(L: int, X: int, n: int = 1):
     """Return a :py:class:`LazyLinOp` to zero-pad each block of a signal.
 
     If you apply this operator to a vector of length L * X the output will
     have a length (L + n) * X.
@@ -708,44 +737,42 @@
     """
     from lazylinop import eye
     if n <= 0:
         # reproducing mpad behaviour
         # (but is that really necessary? why a negative padding size?)
         return eye(X * L, n=X * L, k=0)
     P = ppadder((X, L), ((0, 0), (0, n)), impl='nokron')
-    invalid_ndim_e = ValueError("Invalid number of dimensions (must be <= 2)")
 
     def matmat(x):
         nonlocal P
         ndim = len(x.shape)  # do not use x.ndim in case it is not defined
         if ndim == 1 or x.shape[1] == 1:
             px = P @ x.reshape((X, L))
             return px.ravel() if ndim == 1 else px.reshape(-1,
                                                            1)
         elif ndim == 2:
             xncols = x.shape[1]
             ncols = L * xncols
             mP = ppadder((X, L * x.shape[1]), ((0, 0), (0, n * xncols)),
                          impl='nokron')
             return (mP @ x.reshape(X, ncols)).reshape(-1, xncols)
-        else:
-            raise invalid_ndim_e
+        # else:  x.ndim >= 3 is handled directly in LazyLinOp
 
     def rmatmat(x):
         nonlocal P
         ndim = len(x.shape)  # do not use x.ndim in case it is not defined
         if ndim == 1:
             return P.H @ x
         elif ndim == 2:
             xncols = x.shape[1]
             mP = ppadder((X, L * x.shape[1]), ((0, 0), (0, n * xncols)),
                          impl='nokron')
             return (mP.H @ x.ravel()).reshape(-1, x.shape[1])
-        else:
-            raise invalid_ndim_e
+        # else:  x.ndim >= 3 is handled directly in LazyLinOp
+
     return LazyLinOp(
         shape=(X * (L + n), X * L),
         # it works the same with matvec and rmatvec but it would be slower for
         # x a matrix (LazyLinOp loops on matvec to compute LazyLinOp @ M)
         #        matvec=lambda x: (P @ x.reshape((X, L))).ravel(),
         #        rmatvec=lambda x: (P.H @ x.ravel())
         matmat=matmat,
@@ -787,16 +814,16 @@
     from warnings import warn
     warn("This function is deprecated and should not be used anymore, use"
          " mpad2 -- see issue #57. It will be deleted in a next version.")
     if n <= 0:
         return eye(X * L, n=X * L, k=0)
 
     def _matmat(x):
-        if (X * L) != x.shape[0]:
-            raise ValueError("Invalid block size and/or number of blocks.")
+        # x shape compatibility (number of rows) is tested beforehand by
+        # LazyLinOp class
         if x.ndim == 1:
             is_1d = True
             x = x.reshape(x.shape[0], 1)
         else:
             is_1d = False
         # add n zeros to each block
         y = np.zeros((X * (L + n), x.shape[1]), dtype=x.dtype)
```

## lazylinop/basicops/zeros.py

```diff
@@ -2,30 +2,30 @@
 import numpy as np
 
 
 def zeros(shape, dtype=None):
     """
     Returns a zero :py:class:`LazyLinOp`.
 
-    .. admonition:: Free memory cost
+    .. admonition:: Fixed memory cost
         :class: admonition note
 
-        Whatever is the shape of the ``zeros``, it has no memory cost.
+        Whatever is the shape of the ``zeros``, it has the same memory cost.
 
     Args:
         shape: (``tuple[int, int]``)
              The operator shape.
 
         dtype: (data-type str)
             numpy compliant data-type str (e.g. 'float64').
 
     Example:
-        >>> from lazylinop import zeros
         >>> import numpy as np
-        >>> Lz = zeros((10, 12))
+        >>> import lazylinop as lz
+        >>> Lz = lz.zeros((10, 12))
         >>> x = np.random.rand(12)
         >>> Lz @ x
         array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
 
     .. seealso:: `numpy.zeros <https://numpy.org/doc/stable/reference/
         generated/numpy.zeros.html>`_.
     """
@@ -39,11 +39,11 @@
         # op.ndim > 2 can't happen because of LazyLinOp def
         # op a LazyLinOp can't happen either for the same reason
         if op.ndim == 2:
             return np.zeros((shape[0], op.shape[1]), dtype=dtype)
         else:  # op.ndim == 1: (see LazyLinOp.__matmul__)
             return np.zeros((shape[0],))
     return LazyLinOp(shape, matmat=lambda x:
-                        _matmat(x, shape),
-                        rmatmat=lambda x: _matmat(x, (shape[1],
-                                                      shape[0])),
-                        dtype=dtype)
+                     _matmat(x, shape),
+                     rmatmat=lambda x: _matmat(x, (shape[1],
+                                                   shape[0])),
+                     dtype=dtype)
```

## lazylinop/wip/__init__.py

```diff
@@ -1,3 +1 @@
 from .parallel.mpilop import MPILop # temporary alias (will be deleted later)
-from .polynomial import (poly, cheb, polyval, polyvalfromroots, chebval,
-                         chebvalfromroots, power)
```

## lazylinop/wip/polynomial.py

```diff
@@ -1,801 +1,1260 @@
 """
 Module for polynomial related :py:class:`.LazyLinOp`-s.
 
-It provides "polynomial as :py:class:`.LazyLinOp`" functions for which
+It provides "polynomial for :py:class:`.LazyLinOp`" functions for which
 the polynomial variable is itself a linear operator (especially a
-:py:class:`.LazyLinOp`). Below are the provided functions:
-
-    - :py:func:`.polyval` for evaluating general polynomials.
-    - :py:func:`.chebval` which is specialized for Chebyshev polynomials.
-    - :py:func:`.polyvalfromroots` and :py:func:`.chebvalfromroots` do the same
-      but defining the polynomial from its roots.
+:py:class:`.LazyLinOp`). This allows to build a :py:class:`.LazyLinOp`
+``M=p(L)`` when ``p`` is an instance of a polynomial class inherited
+from NumPy polynomial package and matrix representation of
+:py:class:`.LazyLinOp` ``L`` is square.
+
+Below are the provided classes:
+
+    - :py:class:`.Poly` inherited from `NumPy Polynomial <https:/
+      /numpy.org/doc/stable/reference/generated/
+      numpy.polynomial.polynomial.Polynomial.html>`_,
+    - :py:class:`.Cheb`, inherited from `NumPy Chebyshev <https:/
+      /numpy.org/doc/stable/reference/generated/
+      numpy.polynomial.chebyshev.Chebyshev.html>`_,
+    - :py:class:`.Herm`, inherited from `NumPy Hermite <https:/
+      /numpy.org/doc/stable/reference/generated/
+      numpy.polynomial.hermite.Hermite.html>`_,
+    - :py:class:`.Herme`, inherited from `NumPy HermiteE <https:/
+      /numpy.org/doc/stable/reference/generated/
+      numpy.polynomial.hermite_e.HermiteE.html>`_,
+    - :py:class:`.Lag`, inherited from `NumPy Laguerre <https:/
+      /numpy.org/doc/stable/reference/generated/
+      numpy.polynomial.laguerre.Laguerre.html>`_,
+    - :py:class:`.Leg`, inherited from `NumPy Legendre <https:/
+      /numpy.org/doc/stable/reference/generated/
+      numpy.polynomial.legendre.Legendre.html>`_.
+
+Below are the provided functions:
+
+    - :py:func:`.xpoly` that returns an instance of a polynomial class
+      inherited from NumPy polynomial classes.
+      It could be (specified by :py:func:`xpoly(coef, kind=...)`):
+
+      - ``'cheb'`` which is specialized for Chebyshev polynomials.
+      - ``'herm'`` which is specialized for Hermite
+        "physicists" polynomials.
+      - ``'herme'`` which is specialized for Hermite
+        "probabilists" polynomials.
+      - ``'lag'`` which is specialized for Laguerre polynomials.
+      - ``'leg'`` which is specialized for Legendre polynomials.
+      - ``'roots'`` which defines the polynomial from its roots.
     - :py:func:`.power` for the n-th power of any linear operator.
 
-Besides, the two classes :py:class:`.poly` and :py:class:`.cheb` allow
-to make computations with respectively general polynomials or in particular
-with Chebyshev's. With ``p1`` and ``p2`` two polynomial instances, one can:
-
-    - add/substract: ``(p1 + p2)(Op)``, ``(p1 - p2)(Op)`` with ``Op`` the
-      polynomial variable (a :py:class:`.LazyLinOp`, :py:class:`.poly` or
-      :py:class:`.cheb`). Evaluating and applying the polynomials on the
-      fly is also possible: ``(p1 + p2)(Op) @ x``.
-    - The same is possible to multiply (``@``), divide (``//``) and modulo
-      (``%``) two polynomials (``(p1 @ p2)(Op)``, ``(p1 // p2)(Op)``,
-      ``(p1 % p2)(Op)``.
-    - And compose two polynomials: ``(p1(p2))(Op)`` .
+With ``p1`` and ``p2`` two polynomial instances return by
+:py:func:`xpoly(coef1, kind1)` and :py:func:`xpoly(coef2, kind2)`, one can:
+
+    - add/substract (if ``kind1=kind2``: ``(p1 + p2)(L)``, ``(p1 - p2)(L)``
+      with ``L`` the polynomial variable). Evaluating and applying the
+      polynomials on the fly is also possible: ``(p1 + p2)(L) @ x``.
+    - The same is possible to multiply (``*``), divide (``//``) and modulo
+      (``%``) two polynomials (``(p1 * p2)(L)``, ``(p1 // p2)(L)``,
+      ``(p1 % p2)(L)``.
+    - And compose two polynomials: ``(p1(p2))(L)`` whatever
+      ``kind1`` and ``kind2``.
+    - :octicon:`megaphone;1em;sd-text-danger` Of note, matrix representation
+      of instance ``L`` of :py:class:`.LazyLinOp` must be square.
+    - :octicon:`info;1em;sd-text-success` If ``p`` is in monomial form
+      evaluation of ``p(L) @ x`` uses the
+      `Horner's method <https://en.wikipedia.org/wiki/Horner%27s_method>`_,
+      `Clenshaw algorithm <https://en.wikipedia.org/wiki/Clenshaw_algorithm>`_
+      otherwise.
+    - :octicon:`pin;1em;sd-text-danger` Of note, duration of
+      ``(p1(p2))(L) @ x`` and duration of ``p1(p2(L)) @ x`` might differ
+      when the number of polynomial coefficients is large.
 
 .. admonition:: More details about implementation and features
 
-   The classes :py:class:`.poly` and :py:class:`cheb` extend
-   :py:class:`numpy.polynomial.Polynomial` and
-   :py:class:`numpy.polynomial.Chebyshev`.
+   The :py:func:`xpoly` returns an instance of internal classes that extend
+   NumPy polynomial classes
+   `Polynomial <https://numpy.org/doc/stable/reference/generated/
+   numpy.polynomial.polynomial.Polynomial.html>`_,
+   `Chebyshev <https://numpy.org/doc/stable/reference/generated/
+   numpy.polynomial.chebyshev.Chebyshev.html>`_,
+   `Hermite <https://numpy.org/doc/stable/reference/generated/
+   numpy.polynomial.hermite.Hermite.html>`_,
+   `HermiteE <https://numpy.org/doc/stable/reference/generated/
+   numpy.polynomial.hermite_e.HermiteE.html>`_,
+   `Laguerre <https://numpy.org/doc/stable/reference/generated/
+   numpy.polynomial.laguerre.Laguerre.html>`_,
+   `Legendre <https://numpy.org/doc/stable/reference/generated/
+   numpy.polynomial.legendre.Legendre.html>`_.
+
    They override the method :py:meth:`__call__` to implement the polynomial
    evaluation and calculate on the fly the available operations.
-   Under the hood :py:func:`polyval`, :py:func:`chebval`,
-   :py:func:`hermval`, :py:func:`lagval` or :py:func:`legval` are called
-   depending on the polynomial form.
-.. You can also use :py:func:`chebvalfromroots` that consider polynomial
-   in monomial form before to convert into Chebyshev form.
-   To compute n-th power of a LazyLinOp use :py:func:`power` or
-   create :py:class:`poly` instance such that only n-th coefficient
+   Under the hood evaluation is called depending on the polynomial form.
+.. To compute n-th power of a LazyLinOp use :py:func:`power` or
+   create :py:class:`Poly` instance such that only n-th coefficient
    is equal to one while the others are equal to zero.
 
 """
 
 import numpy as np
 from numpy.polynomial import Polynomial as P
 from numpy.polynomial import Chebyshev as T
 from numpy.polynomial import Hermite as H
+from numpy.polynomial import HermiteE as HE
 from numpy.polynomial import Laguerre as La
 from numpy.polynomial import Legendre as Le
-from lazylinop import binary_dtype, islazylinop, LazyLinOp
-import warnings
-from warnings import warn
-warnings.simplefilter(action='always')
+from lazylinop import binary_dtype, islazylinop, LazyLinOp, aslazylinop
 
 
-def Xpoly(coef, domain=[-1.0, 1.0], window=[-1.0, 1.0],
-          symbol='x', kind: str='monomial'):
-    r"""Return instance amongst P, T, H, La or Le according to kind.
+def xpoly(coef, domain: list = [-1.0, 1.0], window: list = [-1.0, 1.0],
+          symbol: str = 'x', kind: str = 'monomial'):
+    r"""Return instance amongst :py:class:`numpy.polynomial.Polynomial`,
+    :py:class:`numpy.polynomial.Chebyshev`,
+    :py:class:`numpy.polynomial.Hermite`,
+    :py:class:`numpy.polynomial.HermiteE`,
+    :py:class:`numpy.polynomial.Laguerre`
+    or :py:class:`numpy.polynomial.Legendre` according to kind.
+    ``xpoly`` is the extended function for polynomial creation of any
+    kind without using the specialized polynomial classes directly.
+    Under the hood, the function create instance depending on the kind
+    :code:`'cheb'`, :code:`'herm'`, :code:`'herme'`,
+    :code:`'lag'`, :code:`'leg'`, :code:`'monomial'` or
+    :code:`'roots'` of the polynomial you ask for.
+    It is pretty simple and you can construct a polynomial as you
+    would do with a `NumPy polynomial <https://numpy.org/doc/stable/
+    reference/routines.polynomials.classes.html>_`.
 
     Args:
-        coef: list
-            List of coefficients
-        domain: list, optional
-            see :py:class:`numpy.polynomial.Polynomial`
-        window: list, optional
-            see :py:class:`numpy.polynomial.Polynomial`
-        symbol: str, optional
-            see :py:class:`numpy.polynomial.Polynomial`
+        coef: list or 1d array
+            List of coefficients :math:`\lbrack c_0,c_1,\cdots,c_n\rbrack`
+            if :code:`kind!='roots'`:
+
+            .. math::
+
+                \begin{equation}
+                p(L)=\sum_{i=0}^nc_iQ_i(L)
+                \end{equation}
+
+            List of roots :math:`\lbrack r_0,r_1,\cdots,r_n,c_n\rbrack`
+            (where :code:`c_n` is the leading coefficients)
+            if :code:`kind='roots'`:
+
+            .. math::
+
+                \begin{equation}
+                p(L)=c_n\prod_{i=0}^n(L-r_iId)
+                \end{equation}
+
+        .. domain: list, optional
+            See `NumPy documentation <https://numpy.org/doc/stable/reference/
+            generated/numpy.polynomial.polynomial.Polynomial.html#
+            numpy.polynomial.polynomial.Polynomial>`_ for more details.
+        .. window: list, optional
+            See `NumPy documentation <https://numpy.org/doc/stable/reference/
+            generated/numpy.polynomial.polynomial.Polynomial.html#
+            numpy.polynomial.polynomial.Polynomial>`_ for more details.
+        .. symbol: str, optional
+            See `NumPy documentation <https://numpy.org/doc/stable/reference/
+            generated/numpy.polynomial.polynomial.Polynomial.html#
+            numpy.polynomial.polynomial.Polynomial>`_ for more details.
         kind: str, optional
             Representation of the polynomial.
-            It could be 'monomial' (default), 'chebyshev',
-            'hermite' (physicist), 'laguerre', 'legendre' and 'roots'.
+            It could be 'monomial' (default), 'cheb',
+            'herm' physicists polynomials, 'herme' probabilists polynomials,
+            'lag', 'leg' and 'roots'.
             If kind is 'roots', coef is considered to be
             the roots of the polynomial. Leading coefficient is the
-            last element coef[:-1] of coef argument while the first
+            last element :code:`coef[:-1]` of coef argument while the first
             values are the roots of the polynomial.
-            Because of :math:`(Op - r_0Id)\cdots (Op - r_nId)`
-            coefficient :math:`c_n` of the highest power :math:`c_nOp^n`
+            Because of the expression :math:`(L - r_0Id)\cdots (L - r_nId)`
+            coefficient :math:`c_n` of the highest power :math:`c_nL^n`
             is always 1.
 
     Raises:
         ValueError
             coef size must be > 0.
+        Exception
+            coef must be a 1d array.
         ValueError
-            kind must be either monomial, chebyshev, hermite, laguerre, legendre or roots.
+            kind must be either monomial, cheb, herm,
+            herme, lag, leg or roots.
 
     Examples:
-        >>> from lazylinop.wip.polynomial import Xpoly
-        >>> p = Xpoly([1.0, 2.0, 3.0])
+        >>> import numpy as np
+        >>> from lazylinop.wip.polynomial import xpoly
+        >>> p1 = xpoly([1.0, 2.0, 1.0], kind='monomial')
+        >>> p2 = xpoly([-1.0, -1.0, 1.0], kind='roots')
+        >>> np.allclose(p1.coef, p2.coef)
+        True
 
     .. seealso::
         `numpy.polynomial package
         <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
     """
     if type(coef) is list:
         coef = np.asarray(coef)
     if coef.shape[0] < 1:
         raise ValueError("coef size must be > 0.")
+    if coef.ndim != 1:
+        raise Exception("coef must be a 1d array.")
+
     if kind == 'monomial':
-        return poly(coef, domain, window, symbol, form='x')
-    elif kind == 'chebyshev':
-        return cheb(coef, domain, window, symbol)
-    elif kind == 'hermite':
-        return herm(coef, domain, window, symbol)
-    elif kind == 'laguerre':
-        return lag(coef, domain, window, symbol)
-    elif kind == 'legendre':
-        return leg(coef, domain, window, symbol)
+        return Poly(coef, domain, window, symbol, fromRoots=False)
+    elif kind == 'cheb':
+        return Cheb(coef, domain, window, symbol)
+    elif kind == 'herm':
+        return Herm(coef, domain, window, symbol)
+    elif kind == 'herme':
+        return Herme(coef, domain, window, symbol)
+    elif kind == 'lag':
+        return Lag(coef, domain, window, symbol)
+    elif kind == 'leg':
+        return Leg(coef, domain, window, symbol)
     elif kind == 'roots':
         if coef.shape[0] == 1:
-            return poly(coef, domain, window, symbol, form='x')
+            return Poly(coef, domain, window, symbol, fromRoots=False)
         else:
-            return poly(coef, domain, window, symbol, form='roots')
+            return Poly(coef, domain, window, symbol, fromRoots=True)
     else:
-        raise ValueError("kind must be either monomial, chebyshev, hermite, laguerre, legendre or roots.")
+        raise ValueError("kind must be either monomial, cheb," +
+                         " herm, herme, lag, leg or roots.")
+
+
+def _is_lazylinop_poly(p):
+    return isinstance(p, (Poly, Cheb, Herm, Herme, Lag, Leg))
 
 
-def composition(p, op):
-    """Return composition p(op).
+def _kind2class(kind: str):
+    """Return class according to kind.
+    It is useful when user converts polynomial
+    from one kind to another.
 
     Args:
-        p: poly, cheb, herm, lag or leg
-        op: P, T, H, La or Le
+        kind: str
+            Representation of the polynomial.
+            It could be 'monomial' (default), 'cheb',
+            'herm' physicists polynomials,
+            'herme' probabilists polynomials,
+            'lag', 'leg' and 'roots'.
 
     Raises:
-        Exception
-            op must be an instance of either P, T, H, La or Le.
-        Exception
-            p must be an instance of either poly, cheb, herm, lag or leg.
+        ValueError
+            kind must be either monomial, cheb, herm, herme,
+            lag, leg or roots.
+    """
+    if (
+            kind == 'monomial' or
+            kind == 'cheb' or
+            kind == 'herm' or
+            kind == 'herme' or
+            kind == 'lag' or
+            kind == 'leg' or
+            kind == 'roots'
+    ):
+        return xpoly([1.0, 1.0], kind=kind).__class__
+    else:
+        raise ValueError("kind must be either monomial, cheb," +
+                         " herm, herme, lag, leg or roots.")
+
+
+def _compose(p, op):
+    """Returns the composition p(op).
+
+    Args:
+        p: :py:class:`.Poly`, :py:class:`.Cheb`, :py:class:`.Herm`,
+        :py:class:`.Herme`, :py:class:`.Lag` or :py:class:`.Leg`
+        op: :py:class:`.Poly`, :py:class:`.Cheb`, :py:class:`.Herm`,
+        :py:class:`.Herme`, :py:class:`.Lag` or :py:class:`.Leg`
+
+    Raises:
+        TypeError: op or p is not of a valid lazylinop polynomial class.
 
     .. seealso::
         `numpy.polynomial package
         <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
     """
-    if not isinstance(p, poly) and not isinstance(p, cheb) \
-        and not isinstance(p, herm) and not isinstance(p, lag) \
-        and not isinstance(p, leg):
-        raise Exception(
-            "p must be an instance of either poly, cheb, herm, lag or leg.")
-    if isinstance(op, P):
-        tmp = P.__call__(p, op)
-        return poly(tmp.coef, domain=tmp.domain, window=tmp.window)
-    elif isinstance(op, T):
-        tmp = T.__call__(p, op)
-        return cheb(tmp.coef, domain=tmp.domain, window=tmp.window)
-    elif isinstance(op, H):
-        tmp = H.__call__(p, op)
-        return herm(tmp.coef, domain=tmp.domain, window=tmp.window)
-    elif isinstance(op, La):
-        tmp = La.__call__(p, op)
-        return lag(tmp.coef, domain=tmp.domain, window=tmp.window)
-    elif isinstance(op, Le):
-        tmp = Le.__call__(p, op)
-        return leg(tmp.coef, domain=tmp.domain, window=tmp.window)
+    if not _is_lazylinop_poly(p):
+        raise TypeError('p is not a valid lazylinop polynomial')
+    if _is_lazylinop_poly(op):
+        # composition by numpy super class of op
+        tmp = op.__class__.__bases__[0].__call__(p, op)  # np polynomial
+        # then convert to lazylinop poly
+        return op.__class__(tmp.coef, domain=tmp.domain, window=tmp.window)
     else:
-        raise Exception("op must be an instance of either P, T, H, La or Le.")
-        
+        raise TypeError('op is not valid lazylinop polynomial')
 
-class poly(P):
+
+class Poly(P):
     """This class implements a polynomial class derived from
     :py:class:`numpy.polynomial.Polynomial` and so relies on NumPy polynomial
     package to manipulate polynomials.
 
     See :py:mod:`lazylinop.wip.polynomial` for an introduction to implemented
     operations and their basic use.
     """
 
-    def __init__(self, coef, domain=[-1.0, 1.0], window=[-1.0, 1.0],
-                 symbol='x', form: str='x'):
-        """Init instance of poly.
+    def __init__(self, coef, domain: list = [-1.0, 1.0],
+                 window: list = [-1.0, 1.0], symbol: str = 'x',
+                 fromRoots: bool = False):
+        r"""__init__(self, coef, fromRoots: bool = False)
+
+        Init instance of Poly.
+
+        :octicon:`alert-fill;1em;sd-text-danger` Be aware that
+        :code:`Poly(fromRoots=True)(L)` returns
+        :math:`p(L)=c_n\prod_{i=0}^n(L-r_iId)` and not
+        :math:`p(x)=\prod_{i=0}^n(x-r_i)` like
+        `NumPy polyvalfromroots <https://docs.scipy.org/doc/numpy-1.9.3/
+        reference/generated/numpy.polynomial.polynomial.polyvalfromroots.html>`_.
 
         Args:
             coef: list
-                List of coefficients
-            domain: list, optional
-                see :py:class:`numpy.polynomial.Polynomial`
-            window: list, optional
-                see :py:class:`numpy.polynomial.Polynomial`
-            symbol: str, optional
-                see :py:class:`numpy.polynomial.Polynomial`
-            form: str, optional
-            If form is 'x' use polynomial coefficients.
-            If form is 'roots' computes polynomial coefficients
-            from roots. Last element coef[-1] of coef is the
-            leading coefficient.
-
-        Raises:
-            ValueError
-                form must be either 'x' or 'roots'.
+                List of coefficients :math:`\lbrack c_0,c_1,\cdots,c_n\rbrack`
+                if :code:`fromRoots=False`.
+                Polynomial of :py:class:`.LazyLinOp` ``L`` is:
+
+                .. math::
+
+                    \begin{equation}
+                    p(L)=\sum_{i=0}^nc_iL^i
+                    \end{equation}
+
+                List of roots :math:`\lbrack r_0,r_1,\cdots,r_n,c_n\rbrack`
+                (where :code:`c_n` is the leading coefficients)
+                if :code:`fromRoots=True`.
+                Polynomial of :py:class:`.LazyLinOp` ``L`` is:
+
+                .. math::
+
+                    \begin{equation}
+                    p(L)=c_n\prod_{i=0}^n(L-r_iId)
+                    \end{equation}
+
+            .. domain: list, optional
+                See `NumPy documentation <https://numpy.org/doc/stable/
+                reference/generated/
+                numpy.polynomial.polynomial.Polynomial.html#
+                numpy.polynomial.polynomial.Polynomial>`_ for more details.
+            .. window: list, optional
+                See `NumPy documentation <https://numpy.org/doc/
+                stable/reference/generated/
+                numpy.polynomial.polynomial.Polynomial.html#
+                numpy.polynomial.polynomial.Polynomial>`_ for more details.
+            .. symbol: str, optional
+                See `NumPy documentation <https://numpy.org/doc/
+                stable/reference/generated/
+                numpy.polynomial.polynomial.Polynomial.html#
+                numpy.polynomial.polynomial.Polynomial>`_ for more details.
+            fromRoots: bool, optional
+                - If False uses polynomial coefficients.
+                - If True uses polynomial roots.
+                  Last element :code:`coef[-1]` of :code:`coef`
+                  is the leading coefficient.
 
         Examples:
-            >>> from lazylinop.wip.polynomial import poly
-            >>> p = poly([1.0, 2.0, 3.0])
+            >>> import numpy as np
+            >>> from lazylinop.wip.polynomial import Poly
+            >>> p1 = Poly([1.0, 2.0, 1.0], fromRoots=False)
+            >>> p2 = Poly([-1.0, -1.0, 1.0], fromRoots=True)
+            >>> np.allclose(p1.coef, p2.coef)
+            True
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
-        if form == 'x' or coef.shape[0] == 1:
+        coef = np.asarray(coef)
+        if fromRoots is False or coef.shape[0] == 1:
             # If coef.shape is (1, ) there is only leading coefficient
             self.roots = None
             self.leading_coef = coef[-1]
             P.__init__(self, coef, domain, window, symbol)
-        elif form == 'roots':
+        else:
             self.roots = coef[:-1]
             self.leading_coef = coef[-1]
             # Last element coef[-1] of coef is the leading coefficient.
             # np.polynomial.polynomial.polyfromroots does not use it.
-            P.__init__(self, np.polynomial.polynomial.polyfromroots(self.roots),
+            P.__init__(self,
+                       np.polynomial.polynomial.polyfromroots(self.roots),
                        domain, window, symbol)
-        else:
-            raise ValueError("form must be either 'x' or 'roots'.")
 
     def __call__(self, op):
-        """
+        r"""
         Thanks to Python :py:meth:`__call__` instance behaves like function.
-        If op is a LazyLinOp, return polynomial of op applied to a 1d or
-        2d array.
-        If op is a P, T, H, La or Le instance, return a poly instance.
+        If op is a LazyLinOp, return polynomial of op applied to input array.
+        If op is a :py:class:`numpy.polynomial.Polynomial`,
+        :py:class:`numpy.polynomial.Chebyshev`,
+        :py:class:`numpy.polynomial.Hermite`,
+        :py:class:`numpy.polynomial.HermiteE`,
+        :py:class:`numpy.polynomial.Laguerre` or
+        :py:class:`numpy.polynomial.Legendre` instance, return a poly instance.
 
         Args:
-            op: LazyLinOp, P, T, H, La or Le
+            op: :py:class:`numpy.polynomial.Polynomial`,
+            :py:class:`numpy.polynomial.Chebyshev`,
+            :py:class:`numpy.polynomial.Hermite`,
+            :py:class:`numpy.polynomial.HermiteE`,
+            :py:class:`numpy.polynomial.Laguerre` or
+            :py:class:`numpy.polynomial.Legendre` instance
 
         Raises:
             TypeError
                 Unexpected op.
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import poly
-            >>> p = poly([1.0, 2.0, 3.0])
+            >>> from lazylinop.wip.polynomial import Poly
+            >>> p = Poly([1.0, 2.0, 3.0])
             >>> L = eye(3, n=3, k=0)
             >>> islazylinop(p(L))
             True
             >>> x = np.random.randn(3)
             >>> np.allclose(6.0 * x, p(L) @ x)
             True
+
+        .. seealso::
+            `numpy.polynomial package
+            <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
         if islazylinop(op):
             if self.roots is None:
-                return polyval(op, self.coef)
+                return _polyval(op, self.coef)
             else:
-                return polyvalfromroots(op, self.roots)
-        elif isinstance(op, P) or isinstance(op, T) or isinstance(op, H) \
-             or isinstance(op, La) or isinstance(op, Le):
-            return composition(self, op)
+                return self.leading_coef * _polyvalfromroots(op, self.roots)
+        elif _is_lazylinop_poly(op):
+            return _compose(self, op)
         else:
             raise TypeError('Unexpected op.')
 
 
-class cheb(T):
+class Cheb(T):
     """This class implements a Chebyshev polynomial class derived from
     :py:class:`numpy.polynomial.Chebyshev` and so relies on NumPy polynomial
     package to manipulate polynomials.
 
     See :py:mod:`lazylinop.wip.polynomial` for an introduction to implemented
     operations and their basic use.
     """
 
-    def __init__(self, coef, domain=[-1.0, 1.0], window=[-1.0, 1.0],
-                 symbol='x'):
-        """Init instance of cheb.
+    def __init__(self, coef, domain: list = [-1.0, 1.0],
+                 window: list = [-1.0, 1.0], symbol: str = 'x'):
+        r"""Init instance of Cheb.
 
         Args:
             coef: list
-                List of coefficients
-            domain: list, optional
-                see :py:class:`numpy.polynomial.Chebyshev`
-            window: list, optional
-                see :py:class:`numpy.polynomial.Chebyshev`
-            symbol: str, optional
-                see :py:class:`numpy.polynomial.Chebyshev`
+                List of Chebyshev
+                coefficients :math:`\lbrack c_0,c_1,\cdots,c_n\rbrack`.
+                Polynomial of :py:class:`.LazyLinOp` ``L`` is:
+
+                .. math::
+
+                    \begin{equation}
+                    p(L)=\sum_{i=0}^nc_iT_i(L)
+                    \end{equation}
+
+            .. domain: list, optional
+                See `NumPy documentation <https://numpy.org/doc/stable/
+                reference/generated/
+                numpy.polynomial.chebyshev.Chebyshev.html#
+                numpy.polynomial.chebyshev.Chebyshev>`_ for more details.
+            .. window: list, optional
+                See `NumPy documentation <https://numpy.org/doc/
+                stable/reference/generated/
+                numpy.polynomial.chebyshev.Chebyshev.html#
+                numpy.polynomial.chebyshev.Chebyshev>`_ for more details.
+            .. symbol: str, optional
+                See `NumPy documentation <https://numpy.org/doc/
+                stable/reference/generated/
+                numpy.polynomial.chebyshev.Chebyshev.html#
+                numpy.polynomial.chebyshev.Chebyshev>`_ for more details.
 
         Examples:
-            >>> from lazylinop.wip.polynomial import cheb
-            >>> t = cheb([1.0, 2.0, 3.0])
+            >>> from lazylinop.wip.polynomial import Cheb
+            >>> t = Cheb([1.0, 2.0, 3.0])
+            >>> (t + t).coef
+            array([2., 4., 6.])
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
         T.__init__(self, coef, domain, window, symbol)
 
     def __call__(self, op):
         """
         Thanks to Python :py:meth:`__call__` instance behaves like function.
-        If op is a LazyLinOp, return polynomial of op applied to a 1d or
-        2d array.
-        If op is a P, T, H, La or Le instance, return a poly instance.
+        If op is a LazyLinOp, return polynomial of op applied to input array.
+        If op is a :py:class:`numpy.polynomial.Polynomial`,
+        :py:class:`numpy.polynomial.Chebyshev`,
+        :py:class:`numpy.polynomial.Hermite`,
+        :py:class:`numpy.polynomial.HermiteE`,
+        :py:class:`numpy.polynomial.Laguerre` or
+        :py:class:`numpy.polynomial.Legendre` instance, return a poly instance.
 
         Args:
-            op: LazyLinOp, P, T, H, La or Le
+            op: :py:class:`numpy.polynomial.Polynomial`,
+            :py:class:`numpy.polynomial.Chebyshev`,
+            :py:class:`numpy.polynomial.Hermite`,
+            :py:class:`numpy.polynomial.HermiteE`,
+            :py:class:`numpy.polynomial.Laguerre` or
+            :py:class:`numpy.polynomial.Legendre` instance
 
         Raises:
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import cheb
-            >>> t = poly([1.0, 2.0, 3.0])
+            >>> from lazylinop.wip.polynomial import Cheb
+            >>> t = Cheb([1.0, 2.0, 3.0])
             >>> L = eye(3, n=3, k=0)
             >>> islazylinop(t(L))
             True
+
+        .. seealso::
+            `numpy.polynomial package
+            <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
         if islazylinop(op):
-            return chebval(op, self.coef)
-        elif isinstance(op, P) or isinstance(op, T) or isinstance(op, H) \
-             or isinstance(op, La) or isinstance(op, Le):
-            return composition(self, op)
+            return _chebval(op, self.coef)
+        elif _is_lazylinop_poly(op):
+            return _compose(self, op)
         else:
             raise TypeError('Unexpected op.')
 
 
-class herm(H):
-    """This class implements a Hermite (physicist) polynomial class derived from
-    :py:class:`numpy.polynomial.Hermite` and so relies on NumPy polynomial package
-    to manipulate polynomials.
+class Herm(H):
+    """This class implements a Hermite "physicist" polynomial class derived
+    from :py:class:`numpy.polynomial.Hermite` and so relies on NumPy polynomial
+    package to manipulate polynomials.
 
     See :py:mod:`lazylinop.wip.polynomial` for an introduction to implemented
     operations and their basic use.
     """
 
-    def __init__(self, coef, domain=[-1.0, 1.0], window=[-1.0, 1.0],
-                 symbol='x'):
-        """Init instance of herm.
+    def __init__(self, coef, domain: list = [-1.0, 1.0],
+                 window: list = [-1.0, 1.0], symbol: str = 'x'):
+        r"""Init instance of Herm.
 
         Args:
             coef: list
-                List of coefficients
-            domain: list, optional
-                see :py:class:`numpy.polynomial.Hermite`
-            window: list, optional
-                see :py:class:`numpy.polynomial.Hermite`
-            symbol: str, optional
-                see :py:class:`numpy.polynomial.Hermite`
+                List of Hermite coefficients
+                :math:`\lbrack c_0,c_1,\cdots,c_n\rbrack`.
+                Polynomial of :py:class:`.LazyLinOp` ``L`` is:
+
+                .. math::
+
+                    \begin{equation}
+                    p(L)=\sum_{i=0}^nc_iH_i(L)
+                    \end{equation}
+
+            .. domain: list, optional
+                See `NumPy documentation <https://numpy.org/doc/stable/
+                reference/generated/
+                numpy.polynomial.hermite.Hermite.html#
+                numpy.polynomial.hermite.Hermite>`_ for more details.
+            .. window: list, optional
+                See `NumPy documentation <https://numpy.org/doc/
+                stable/reference/generated/
+                numpy.polynomial.hermite.Hermite.html#
+                numpy.polynomial.hermite.Hermite>`_ for more details.
+            .. symbol: str, optional
+                See `NumPy documentation <https://numpy.org/doc/
+                stable/reference/generated/
+                numpy.polynomial.hermite.Hermite.html#
+                numpy.polynomial.hermite.Hermite>`_ for more details.
 
         Examples:
-            >>> from lazylinop.wip.polynomial import herm
-            >>> h = herm([1.0, 2.0, 3.0])
+            >>> from lazylinop.wip.polynomial import Herm
+            >>> h = Herm([1.0, 2.0, 3.0])
+            >>> (h + h).coef
+            array([2., 4., 6.])
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
         H.__init__(self, coef, domain, window, symbol)
 
     def __call__(self, op):
         """
         Thanks to Python :py:meth:`__call__` instance behaves like function.
-        If op is a LazyLinOp, return polynomial of op applied to a 1d or
-        2d array.
-        If op is a P, T, H, La or Le instance, return a poly instance.
+        If op is a LazyLinOp, return polynomial of op applied to input array.
+        If op is a :py:class:`numpy.polynomial.Polynomial`,
+        :py:class:`numpy.polynomial.Chebyshev`,
+        :py:class:`numpy.polynomial.Hermite`,
+        :py:class:`numpy.polynomial.HermiteE`,
+        :py:class:`numpy.polynomial.Laguerre` or
+        :py:class:`numpy.polynomial.Legendre` instance, return a poly instance.
 
         Args:
-            op: LazyLinOp, P, T, H, La or Le
+            op: LazyLinOp,
+            :py:class:`numpy.polynomial.Polynomial`,
+            :py:class:`numpy.polynomial.Chebyshev`,
+            :py:class:`numpy.polynomial.Hermite`,
+            :py:class:`numpy.polynomial.HermiteE`,
+            :py:class:`numpy.polynomial.Laguerre` or
+            :py:class:`numpy.polynomial.Legendre` instance
 
         Raises:
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import herm
-            >>> h = herm([1.0, 2.0, 3.0])
+            >>> from lazylinop.wip.polynomial import Herm
+            >>> h = Herm([1.0, 2.0, 3.0])
             >>> L = eye(3, n=3, k=0)
             >>> islazylinop(h(L))
             True
+
+        .. seealso::
+            `numpy.polynomial package
+            <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
         if islazylinop(op):
-            return hermval(op, self.coef)
-        elif isinstance(op, P) or isinstance(op, T) or isinstance(op, H) \
-             or isinstance(op, La) or isinstance(op, Le):
-            return composition(self, op)
+            return _hermval(op, self.coef)
+        elif _is_lazylinop_poly(op):
+            return _compose(self, op)
         else:
             raise TypeError('Unexpected op.')
 
 
-class lag(H):
-    """This class implements a Laguerre polynomial class derived from
-    :py:class:`numpy.polynomial.Laguerre` and so relies on NumPy polynomial package
-    to manipulate polynomials.
+class Herme(HE):
+    """This class implements a Hermite "probabilist" polynomial class derived
+    from :py:class:`numpy.polynomial.HermiteE` and so relies on NumPy
+    polynomial package to manipulate polynomials.
 
     See :py:mod:`lazylinop.wip.polynomial` for an introduction to implemented
     operations and their basic use.
     """
 
-    def __init__(self, coef, domain=[-1.0, 1.0], window=[-1.0, 1.0],
-                 symbol='x'):
-        """Init instance of lag.
+    def __init__(self, coef, domain: list = [-1.0, 1.0],
+                 window: list = [-1.0, 1.0], symbol: str = 'x'):
+        r"""Init instance of Herme.
 
         Args:
             coef: list
-                List of coefficients
-            domain: list, optional
-                see :py:class:`numpy.polynomial.Laguerre`
-            window: list, optional
-                see :py:class:`numpy.polynomial.Laguerre`
-            symbol: str, optional
-                see :py:class:`numpy.polynomial.Laguerre`
+                List of Hermite coefficients
+                :math:`\lbrack c_0,c_1,\cdots,c_n\rbrack`.
+                Polynomial of :py:class:`.LazyLinOp` ``L`` is:
+
+                .. math::
+
+                    \begin{equation}
+                    p(L)=\sum_{i=0}^nc_iH_i(L)
+                    \end{equation}
+
+            .. domain: list, optional
+                See `NumPy documentation <https://numpy.org/doc/stable/
+                reference/generated/
+                numpy.polynomial.hermite_e.HermiteE.html#
+                numpy.polynomial.hermite_e.HermiteE>`_ for more details.
+            .. window: list, optional
+                See `NumPy documentation <https://numpy.org/doc/
+                stable/reference/generated/
+                numpy.polynomial.hermite_e.HermiteE.html#
+                numpy.polynomial.hermite_e.HermiteE>`_ for more details.
+            .. symbol: str, optional
+                See `NumPy documentation <https://numpy.org/doc/
+                stable/reference/generated/
+                numpy.polynomial.hermite_e.HermiteE.html#
+                numpy.polynomial.hermite_e.HermiteE>`_ for more details.
 
         Examples:
-            >>> from lazylinop.wip.polynomial import lag
-            >>> la = lag([1.0, 2.0, 3.0])
+            >>> from lazylinop import eye, islazylinop
+            >>> from lazylinop.wip.polynomial import Herme
+            >>> h = Herme([1.0, 2.0, 3.0])
+            >>> (h + h).coef
+            array([2., 4., 6.])
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
-        H.__init__(self, coef, domain, window, symbol)
+        HE.__init__(self, coef, domain, window, symbol)
 
     def __call__(self, op):
         """
         Thanks to Python :py:meth:`__call__` instance behaves like function.
-        If op is a LazyLinOp, return polynomial of op applied to a 1d or
-        2d array.
-        If op is a P, T, H, La or Le instance, return a poly instance.
+        If op is a LazyLinOp, return polynomial of op applied to input array.
+        If op is a :py:class:`numpy.polynomial.Polynomial`,
+        :py:class:`numpy.polynomial.Chebyshev`,
+        :py:class:`numpy.polynomial.Hermite`,
+        :py:class:`numpy.polynomial.HermiteE`,
+        :py:class:`numpy.polynomial.Laguerre` or
+        :py:class:`numpy.polynomial.Legendre` instance, return a poly instance.
 
         Args:
-            op: LazyLinOp, P, T, H, La or Le
+            op: :py:class:`numpy.polynomial.Polynomial`,
+            :py:class:`numpy.polynomial.Chebyshev`,
+            :py:class:`numpy.polynomial.Hermite`,
+            :py:class:`numpy.polynomial.HermiteE`,
+            :py:class:`numpy.polynomial.Laguerre` or
+            :py:class:`numpy.polynomial.Legendre` instance
 
         Raises:
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import lag
-            >>> la = lag([1.0, 2.0, 3.0])
+            >>> from lazylinop.wip.polynomial import herme
+            >>> h = herme([1.0, 2.0, 3.0])
             >>> L = eye(3, n=3, k=0)
-            >>> islazylinop(la(L))
+            >>> islazylinop(h(L))
             True
+
+        .. seealso::
+            `numpy.polynomial package
+            <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
         if islazylinop(op):
-            return lagval(op, self.coef)
-        elif isinstance(op, P) or isinstance(op, T) or isinstance(op, H) \
-             or isinstance(op, La) or isinstance(op, Le):
-            return composition(self, op)
+            return _hermval(op, self.coef, False)
+        elif _is_lazylinop_poly(op):
+            return _compose(self, op)
         else:
             raise TypeError('Unexpected op.')
 
 
-class leg(H):
-    """This class implements a Legendre polynomial class derived from
-    :py:class:`numpy.polynomial.Legendre` and so relies on NumPy polynomial package
-    to manipulate polynomials.
+class Lag(La):
+    """This class implements a Laguerre polynomial class derived from
+    :py:class:`numpy.polynomial.Laguerre` and so relies on NumPy polynomial
+    package to manipulate polynomials.
 
     See :py:mod:`lazylinop.wip.polynomial` for an introduction to implemented
     operations and their basic use.
     """
 
-    def __init__(self, coef, domain=[-1.0, 1.0], window=[-1.0, 1.0],
-                 symbol='x'):
-        """Init instance of leg.
+    def __init__(self, coef, domain: list = [-1.0, 1.0],
+                 window: list = [-1.0, 1.0], symbol: str = 'x'):
+        r"""Init instance of Lag.
 
         Args:
             coef: list
-                List of coefficients
-            domain: list, optional
-                see :py:class:`numpy.polynomial.Legendre`
-            window: list, optional
-                see :py:class:`numpy.polynomial.Legendre`
-            symbol: str, optional
-                see :py:class:`numpy.polynomial.Legendre`
+                List of Laguerre coefficients
+                :math:`\lbrack c_0,c_1,\cdots,c_n\rbrack`.
+                Polynomial of :py:class:`.LazyLinOp` ``L`` is:
+
+                .. math::
+
+                    \begin{equation}
+                    p(L)=\sum_{i=0}^nc_iL_{a,i}(L)
+                    \end{equation}
+
+            .. domain: list, optional
+                See `NumPy documentation <https://numpy.org/doc/stable/
+                reference/generated/
+                numpy.polynomial.laguerre.Laguerre.html#
+                numpy.polynomial.laguerre.Laguerre>`_ for more details.
+            .. window: list, optional
+                See `NumPy documentation <https://numpy.org/doc/
+                stable/reference/generated/
+                numpy.polynomial.laguerre.Laguerre.html#
+                numpy.polynomial.laguerre.Laguerre>`_ for more details.
+            .. symbol: str, optional
+                See `NumPy documentation <https://numpy.org/doc/
+                stable/reference/generated/
+                numpy.polynomial.laguerre.Laguerre.html#
+                numpy.polynomial.laguerre.Laguerre>`_ for more details.
 
         Examples:
-            >>> from lazylinop.wip.polynomial import leg
-            >>> le = leg([1.0, 2.0, 3.0])
+            >>> from lazylinop import eye, islazylinop
+            >>> from lazylinop.wip.polynomial import Lag
+            >>> la = Lag([1.0, 2.0, 3.0])
+            >>> (la + la).coef
+            array([2., 4., 6.])
+            >>> L = eye(3, n=3, k=0)
+            >>> islazylinop(la(L))
+            True
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
-        H.__init__(self, coef, domain, window, symbol)
+        La.__init__(self, coef, domain, window, symbol)
 
     def __call__(self, op):
         """
         Thanks to Python :py:meth:`__call__` instance behaves like function.
-        If op is a LazyLinOp, return polynomial of op applied to a 1d or
-        2d array.
-        If op is a P, T, H, La or Le instance, return a poly instance.
+        If op is a LazyLinOp, return polynomial of op applied to input array.
+        If op is a :py:class:`numpy.polynomial.Polynomial`,
+        :py:class:`numpy.polynomial.Chebyshev`,
+        :py:class:`numpy.polynomial.Hermite`,
+        :py:class:`numpy.polynomial.HermiteE`,
+        :py:class:`numpy.polynomial.Laguerre` or
+        :py:class:`numpy.polynomial.Legendre` instance, return a poly instance.
 
         Args:
-            op: LazyLinOp, P, T, H, La or Le
+            op: :py:class:`numpy.polynomial.Polynomial`,
+            :py:class:`numpy.polynomial.Chebyshev`,
+            :py:class:`numpy.polynomial.Hermite`,
+            :py:class:`numpy.polynomial.HermiteE`,
+            :py:class:`numpy.polynomial.Laguerre` or
+            :py:class:`numpy.polynomial.Legendre` instance
 
         Raises:
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import leg
-            >>> le = leg([1.0, 2.0, 3.0])
+            >>> from lazylinop.wip.polynomial import Lag
+            >>> la = Lag([1.0, 2.0, 3.0])
             >>> L = eye(3, n=3, k=0)
-            >>> islazylinop(le(L))
+            >>> islazylinop(la(L))
             True
+
+        .. seealso::
+            `numpy.polynomial package
+            <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
         if islazylinop(op):
-            return legval(op, self.coef)
-        elif isinstance(op, P) or isinstance(op, T) or isinstance(op, H) \
-             or isinstance(op, La) or isinstance(op, Le):
-            return composition(self, op)
+            return _lagval(op, self.coef)
+        elif _is_lazylinop_poly(op):
+            return _compose(self, op)
         else:
             raise TypeError('Unexpected op.')
 
 
-def chebval(L, c):
-    r"""Constructs a :py:class:`.LazyLinOp` Chebysev polynomial ``P(L)`` of
-    linear operator ``L``.
+class Leg(Le):
+    """This class implements a Legendre polynomial class derived from
+    :py:class:`numpy.polynomial.Legendre` and so relies on NumPy polynomial
+    package to manipulate polynomials.
 
-    ``P(L)`` is equal to :math:`c_0Id + c_1T_1(L) + \cdots + c_nT_n(L)`.
+    See :py:mod:`lazylinop.wip.polynomial` for an introduction to implemented
+    operations and their basic use.
+    """
 
-    The k-th Chebyshev polynomial can be computed by recurrence:
+    def __init__(self, coef, domain: list = [-1.0, 1.0],
+                 window: list = [-1.0, 1.0], symbol: str = 'x'):
+        r"""Init instance of Leg.
 
-    .. math::
+        Args:
+            coef: list
+                List of Legendre coefficients
+                :math:`\lbrack c_0,c_1,\cdots,c_n\rbrack`.
+                Polynomial of :py:class:`.LazyLinOp` ``L`` is:
+
+                .. math::
+
+                    \begin{equation}
+                    p(L)=\sum_{i=0}^nc_iL_{e,i}(L)
+                    \end{equation}
+
+            .. domain: list, optional
+                See `NumPy documentation <https://numpy.org/doc/stable/
+                reference/generated/
+                numpy.polynomial.legendre.Legendre.html#
+                numpy.polynomial.legendre.Legendre>`_ for more details.
+            .. window: list, optional
+                See `NumPy documentation <https://numpy.org/doc/
+                stable/reference/generated/
+                numpy.polynomial.legendre.Legendre.html#
+                numpy.polynomial.legendre.Legendre>`_ for more details.
+            .. symbol: str, optional
+                See `NumPy documentation <https://numpy.org/doc/
+                stable/reference/generated/
+                numpy.polynomial.legendre.Legendre.html#
+                numpy.polynomial.legendre.Legendre>`_ for more details.
 
-        \begin{eqnarray}
-        T_0(L) &=& 1\\
-        T_1(L) &=& L\\
-        T_{k+1}(L) &=& 2LT_k(L) - T_{k-1}(L)
-        \end{eqnarray}
+        Examples:
+            >>> from lazylinop import eye, islazylinop
+            >>> from lazylinop.wip.polynomial import Leg
+            >>> le = Leg([1.0, 2.0, 3.0])
+            >>> (le + le).coef
+            array([2., 4., 6.])
+            >>> L = eye(3, n=3, k=0)
+            >>> islazylinop(le(L))
+            True
 
-    The Clenshaw's method is used to compute ``P(L) @ X``.
+        .. seealso::
+            `numpy.polynomial package
+            <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
+        """
+        Le.__init__(self, coef, domain, window, symbol)
 
-    ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
+    def __call__(self, op):
+        """
+        Thanks to Python :py:meth:`__call__` instance behaves like function.
+        If op is a LazyLinOp, return polynomial of op applied to input array.
+        If op is a :py:class:`numpy.polynomial.Polynomial`,
+        :py:class:`numpy.polynomial.Chebyshev`,
+        :py:class:`numpy.polynomial.Hermite`,
+        :py:class:`numpy.polynomial.HermiteE`,
+        :py:class:`numpy.polynomial.Laguerre` or
+        :py:class:`numpy.polynomial.Legendre` instance.
+
+        Args:
+            op: LazyLinOp,
+            :py:class:`numpy.polynomial.Polynomial`,
+            :py:class:`numpy.polynomial.Chebyshev`,
+            :py:class:`numpy.polynomial.Hermite`,
+            :py:class:`numpy.polynomial.HermiteE`,
+            :py:class:`numpy.polynomial.Laguerre` or
+            :py:class:`numpy.polynomial.Legendre` instance
+
+        Raises:
+
+        Examples:
+            >>> from lazylinop import eye, islazylinop
+            >>> from lazylinop.wip.polynomial import Leg
+            >>> le = Leg([1.0, 2.0, 3.0])
+            >>> L = eye(3, n=3, k=0)
+            >>> islazylinop(le(L))
+            True
+
+        .. seealso::
+            `numpy.polynomial package
+            <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
+        """
+        if islazylinop(op):
+            return _legval(op, self.coef)
+        elif _is_lazylinop_poly(op):
+            return _compose(self, op)
+        else:
+            raise TypeError('Unexpected op.')
 
 
+def _polyval(L, c):
+    r"""Constructs a :py:class:`.LazyLinOp` polynomial ``P(L)`` of linear
+    operator ``L``.
+
+    ``P(L)`` is equal to :math:`c_0Id+c_1L^1+\cdots +c_nL^n`.
+
+    ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
+
     Args:
-        L: 2d array
-            Linear operator.
+        L: LazyLinOp
+            Linear operator (matrix representation must be square).
         c: 1d array
-            List of Chebyshev polynomial(s) coefficients.
+            List of polynomial coefficients.
             If the size of the 1d array is n + 1 then the largest power of the
             polynomial is n.
 
     Returns:
         LazyLinOp
 
     Raises:
         Exception
             Matrix representation of L is not square.
-        ValueError
-            L @ x does not work because # of columns of L is not equal to the
-            # of rows of x.
-        ValueError
+        Exception
             List of coefficients has zero size.
+        Exception
+            coef must be a 1d array.
 
     Examples:
         >>> import numpy as np
         >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import chebval
+        >>> from lazylinop.wip.polynomial import polyval
         >>> x = np.random.randn(3)
         >>> L = eye(3, n=3, k=0)
-        >>> y = chebval(L, [1.0, 2.0, 3.0]) @ x
+        >>> y = polyval(L, [1.0, 2.0, 3.0]) @ x
         >>> np.allclose(6.0 * x, y)
         True
 
     .. seealso::
-        - `Wikipedia <https://en.wikipedia.org/wiki/Chebyshev_polynomials>`_,
-        - `Polynomial magic web page
-          <https://francisbach.com/chebyshev-polynomials/>`_,
         - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
-          reference/generated/numpy.polynomial.chebyshev.chebval.html>`_.
+          reference/generated/numpy.polynomial.polynomial.polyval.html>`_.
+        - :py:func:`polyvalfromroots`.
     """
 
     if L.shape[0] != L.shape[1]:
         raise Exception("Matrix representation of L is not square.")
 
-    if type(c) is list:
-        c = np.asarray(c)
+    c = np.asarray(c)
+
+    if c.ndim != 1:
+        raise Exception("coef must be a 1d array.")
 
-    if c.ndim == 2:
-        # Only one polynomial
-        c = np.copy(c[:, 0].flatten())
     D = c.shape[0]
     if D == 0:
-        raise ValueError("List of coefficients has zero size.")
+        raise Exception("List of coefficients has zero size.")
 
     def _matmat(L, x, c):
-        if L.shape[1] != x.shape[0]:
-            raise ValueError("L @ x does not work because # of columns of L is"
-                             " not equal to the # of rows of x.")
+        # x can't be a LazyLinOp here because it's handle before in
+        # LazyLinOp.__matmul__
         if x.ndim == 1:
-            is_1d = True
-            x = x.reshape(x.shape[0], 1)
+            x1d = True
+            x = x.reshape(-1, 1)
         else:
-            is_1d = False
-        batch_size = x.shape[1]
-        output = np.empty((L.shape[0], batch_size),
+            x1d = False
+        out = (
+            x * c[-1] if c[-1] != 0
+            else np.zeros(x.shape,
                           dtype=binary_dtype(c.dtype, x.dtype))
-        T0x = np.empty((L.shape[0], batch_size),
-                       dtype=binary_dtype(c.dtype, x.dtype))
-        T1x = np.empty((L.shape[0], batch_size),
-                       dtype=binary_dtype(c.dtype, x.dtype))
-        T2x = np.empty((L.shape[0], batch_size),
-                       dtype=binary_dtype(c.dtype, x.dtype))
-        np.copyto(T0x, x)
-        np.copyto(output[:, :], np.multiply(c[0], T0x))
-        if D > 1:
-            # loop over the coefficients
-            for i in range(1, D):
-                if i == 1:
-                    np.copyto(T1x, L @ x)
-                    if c[i] == 0.0:
-                        continue
-                    else:
-                        np.add(output, np.multiply(c[i], T1x), out=output)
-                else:
-                    np.copyto(T2x, np.subtract(np.multiply(2.0, L @ T1x), T0x))
-                    # Recurrence
-                    np.copyto(T0x, T1x)
-                    np.copyto(T1x, T2x)
-                    if c[i] == 0.0:
-                        continue
-                    else:
-                        np.add(output, np.multiply(c[i], T2x), out=output)
-        return output.ravel() if is_1d else output
+        )
+        for i in range(len(c) - 2, -1, -1):
+            out = L @ out
+            if c[i] != 0:
+                out += x * c[i]
+        return out.ravel() if x1d else out
 
     return LazyLinOp(
         shape=L.shape,
         matmat=lambda x: _matmat(L, x, c),
         rmatmat=lambda x: _matmat(L.T.conj(), x, c)
     )
 
 
-def chebvalfromroots(L, r):
-    r"""Constructs a :py:class:`.LazyLinOp` Chebyshev polynomial
+def _polyvalfromroots(L, r):
+    r"""Constructs a :py:class:`.LazyLinOp` polynomial
     ``P(L)`` of linear operator ``L`` from the polynomial roots.
 
-    ``P(L)`` is equal to :math:`(L - r_0Id)(L - r_1Id)\cdots (L - r_nId)`.
+    ``P(L)`` is equal to :math:`(L - r_0Id)(L - r_1)\cdots (L - r_nId)`.
 
     ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
 
     Args:
-        L: 2d array
-            Linear operator.
+        L: LazyLinOp
+            Linear operator (matrix representation must be square).
         r: 1d array
-            List of Chebyshev polynomial roots.
-            If the size of the list is n + 1 then the largest power of the
+            List of polynomial roots.
+
+    Returns:
+        LazyLinOp
+
+    Raises:
+        Exception
+            Matrix representation of L is not square.
+        Exception
+            List of roots has zero size.
+        Exception
+            roots must be a 1d array.
+
+    Examples:
+        >>> import numpy as np
+        >>> from lazylinop import eye
+        >>> from lazylinop.wip.polynomial import _polyvalfromroots
+        >>> x = np.random.randn(3)
+        >>> L = eye(3, n=3, k=0)
+        >>> y = _polyvalfromroots(L, [1.0, 1.0, 1.0]) @ x
+        >>> np.allclose(0.0 * x, y)
+        True
+
+    .. seealso::
+        - `NumPy polyvalfromroots <https://docs.scipy.org/doc/
+          numpy-1.9.3/reference/generated/numpy.polynomial.polynomial.
+          polyvalfromroots.html>`_.
+        - :py:func:`polyval`.
+    """
+
+    if L.shape[0] != L.shape[1]:
+        raise Exception("Matrix representation of L is not square.")
+
+    r = np.asarray(r)
+
+    if r.ndim != 1:
+        raise Exception("roots must be a 1d array.")
+
+    R = r.shape[0]
+    if R == 0:
+        raise Exception("List of roots has zero size.")
+
+    def _matmat(roots, L, x):
+        if x.ndim == 1:
+            is_1d = True
+            x = x.reshape(x.shape[0], 1)
+        else:
+            is_1d = False
+
+        Lx = L @ x if roots[-1] == 0 else (L @ x - roots[-1] * x)
+        nr = len(roots)
+
+        for i in range(nr - 2, -1, -1):
+            r = roots[i]
+            Lx = L @ Lx if r == 0.0 else (L @ Lx - r * Lx)
+
+        return Lx.ravel() if is_1d else Lx
+
+    return LazyLinOp(
+        shape=L.shape,
+        matmat=lambda x: _matmat(r, L, x),
+        rmatmat=lambda x: _matmat(r, L.T.conj(), x)
+    )
+
+
+def _chebval(L, c):
+    r"""Constructs a :py:class:`.LazyLinOp` Chebysev polynomial ``P(L)`` of
+    linear operator ``L``.
+
+    ``P(L)`` is equal to :math:`c_0Id+c_1T_1(L)+\cdots +c_nT_n(L)`.
+
+    The k-th Chebyshev polynomial can be computed by recurrence:
+
+    .. math::
+
+        \begin{eqnarray}
+        T_0(L) &=& 1\\
+        T_1(L) &=& L\\
+        T_{k+1}(L) &=& 2LT_k(L) - T_{k-1}(L)
+        \end{eqnarray}
+
+    The Clenshaw's method is used to compute ``P(L) @ X``.
+
+    ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
+
+
+    Args:
+        L: LazyLinOp
+            Linear operator (matrix representation must be square).
+        c: 1d array
+            List of Chebyshev polynomial(s) coefficients.
+            If the size of the 1d array is n + 1 then the largest power of the
             polynomial is n.
 
     Returns:
         LazyLinOp
 
     Raises:
-        ValueError
+        Exception
+            Matrix representation of L is not square.
+        Exception
             List of coefficients has zero size.
+        Exception
+            coef must be a 1d array.
 
     Examples:
         >>> import numpy as np
         >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import chebvalfromroots
+        >>> from lazylinop.wip.polynomial import _chebval
         >>> x = np.random.randn(3)
         >>> L = eye(3, n=3, k=0)
-        >>> y = chebvalfromroots(L, [1.0, 1.0]) @ x
-        >>> np.allclose(0.0 * x, y)
+        >>> y = _chebval(L, [1.0, 2.0, 3.0]) @ x
+        >>> np.allclose(6.0 * x, y)
         True
 
     .. seealso::
         - `Wikipedia <https://en.wikipedia.org/wiki/Chebyshev_polynomials>`_,
         - `Polynomial magic web page
           <https://francisbach.com/chebyshev-polynomials/>`_,
-        - `NumPy polynomial cheval
-          <https://docs.scipy.org/doc//numpy-1.9.3/reference/generated/numpy.polynomial.chebyshev.chebval.html>`_,
-        - `NumPy polynomial chebfromroots
-          <https://docs.scipy.org/doc//numpy-1.9.3/reference/generated/numpy.polynomial.chebyshev.chebfromroots.html>`_,
-        - :py:func:`chebval`.
-    """
-    if type(r) is list:
-        r = np.asarray(r)
-    if r.ndim == 2:
-        # Only one polynomial
-        r = np.copy(r[:, 0].flatten())
-    if r.shape[0] == 0:
-        raise ValueError("List of roots has zero size.")
-    return chebval(L, np.polynomial.chebyshev.chebfromroots(r))
-
-
-def hermval(L, c):
-    r"""Constructs a :py:class:`.LazyLinOp` Hermite (physicist)
-    polynomial ``P(L)`` of linear operator ``L``.
+        - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
+          reference/generated/numpy.polynomial.chebyshev.chebval.html>`_.
+    """
 
-    ``P(L)`` is equal to :math:`c_0Id + c_1H_1(L) + \cdots + c_nH_n(L)`.
+    if L.shape[0] != L.shape[1]:
+        raise Exception("Matrix representation of L is not square.")
+
+    c = np.asarray(c)
+
+    D = c.shape[0]
+    if D == 0:
+        raise Exception("List of coefficients has zero size.")
+
+    if c.ndim != 1:
+        raise Exception("coef must be a 1d array.")
+
+    clenshaw_funcs = [lambda k, L, bk: L @ (2 * bk),  # alpha(k)
+                      lambda k: 1,  # beta(k)
+                      lambda L, bk: L @ bk]  # phi1(L)
+
+    return LazyLinOp(
+        shape=L.shape,
+        matmat=lambda x: _matmat_clenshaw(L, c, x, *clenshaw_funcs),
+        rmatmat=lambda x: _matmat_clenshaw(L.T.conj(), c, x, *clenshaw_funcs)
+    )
+
+
+def _hermval(L, c, physicist: bool = True):
+    r"""Constructs a :py:class:`.LazyLinOp` Hermite (physicist or
+    probabilistic) polynomial ``P(L)`` of linear operator ``L``.
+
+    ``P(L)`` is equal to :math:`c_0Id+c_1H_1(L)+\cdots +c_nH_n(L)`.
 
     The k-th Hermite (physicist) polynomial can be computed by recurrence:
 
     .. math::
 
         \begin{eqnarray}
         H_0(L) &=& Id\\
         H_1(L) &=& 2L\\
         H_{k+1}(L) &=& 2LH_k(L) - 2kH_{k-1}(L)
         \end{eqnarray}
 
+    The k-th Hermite (probabilist) polynomial can be computed by recurrence:
+
+    .. math::
+
+        \begin{eqnarray}
+        H_0(L) &=& Id\\
+        H_1(L) &=& L\\
+        H_{k+1}(L) &=& LH_k(L) - kH_{k-1}(L)
+        \end{eqnarray}
+
     The Clenshaw's method is used to compute ``P(L) @ X``.
 
     ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
 
 
     Args:
-        L: 2d array
-            Linear operator.
+        L: LazyLinOp
+            Linear operator (matrix representation must be square).
         c: 1d array
             List of Hermite (physicist) polynomial(s) coefficients.
             If the size of the 1d array is n + 1 then the largest power of the
             polynomial is n.
+        physicist: bool, optional
+            If True (default) construct Hermite "physicist" polynomial.
+            If False construct Hermite "probabilistic" polynomial.
 
     Returns:
         LazyLinOp
 
     Raises:
         Exception
             Matrix representation of L is not square.
-        ValueError
-            L @ x does not work because # of columns of L is not equal to the
-            # of rows of x.
-        ValueError
+        Exception
             List of coefficients has zero size.
+        Exception
+            coef must be a 1d array.
 
     Examples:
         >>> import numpy as np
         >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import hermval
+        >>> from lazylinop.wip.polynomial import _hermval
         >>> x = np.array([1.0, 0.0, 0.0])
         >>> L = eye(3, n=3, k=0)
-        >>> y = hermval(L, [1.0, 2.0, 3.0]) @ x
+        >>> y = _hermval(L, [1.0, 2.0, 3.0]) @ x
         >>> z = np.polynomial.hermite.hermval(x[0], [1.0, 2.0, 3.0])
         >>> np.allclose(y[0], z)
         True
 
     .. seealso::
         - `Wikipedia <https://en.wikipedia.org/wiki/Hermite_polynomials>`_,
         - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
           reference/generated/numpy.polynomial.hermite.hermval.html>`_.
     """
 
     if L.shape[0] != L.shape[1]:
         raise Exception("Matrix representation of L is not square.")
 
-    if type(c) is list:
-        c = np.asarray(c)
+    c = np.asarray(c)
 
-    if c.ndim == 2:
-        # Only one polynomial
-        c = np.copy(c[:, 0].flatten())
     D = c.shape[0]
     if D == 0:
-        raise ValueError("List of coefficients has zero size.")
+        raise Exception("List of coefficients has zero size.")
 
-    def _matmat(L, x, c):
-        if L.shape[1] != x.shape[0]:
-            raise ValueError("L @ x does not work because # of columns of L is"
-                             " not equal to the # of rows of x.")
-        if x.ndim == 1:
-            is_1d = True
-            x = x.reshape(x.shape[0], 1)
-        else:
-            is_1d = False
-        batch_size = x.shape[1]
-        output = np.empty((L.shape[0], batch_size),
-                          dtype=binary_dtype(c.dtype, x.dtype))
-        H0x = np.empty((L.shape[0], batch_size),
-                       dtype=binary_dtype(c.dtype, x.dtype))
-        H1x = np.empty((L.shape[0], batch_size),
-                       dtype=binary_dtype(c.dtype, x.dtype))
-        H2x = np.empty((L.shape[0], batch_size),
-                       dtype=binary_dtype(c.dtype, x.dtype))
-        np.copyto(H0x, x)
-        np.copyto(output[:, :], np.multiply(c[0], H0x))
-        if D > 1:
-            # loop over the coefficients
-            for i in range(1, D):
-                if i == 1:
-                    np.copyto(H1x, np.multiply(2.0, L @ x))
-                    if c[i] == 0.0:
-                        continue
-                    else:
-                        np.add(output, np.multiply(c[i], H1x), out=output)
-                else:
-                    np.copyto(H2x, np.subtract(np.multiply(2.0, L @ H1x), np.multiply(2 * (i - 1), H0x)))
-                    # Recurrence
-                    np.copyto(H0x, H1x)
-                    np.copyto(H1x, H2x)
-                    if c[i] == 0.0:
-                        continue
-                    else:
-                        np.add(output, np.multiply(c[i], H2x), out=output)
-        return output.ravel() if is_1d else output
+    if c.ndim != 1:
+        raise Exception("coef must be a 1d array.")
+
+    if physicist:
+        clenshaw_funcs = [
+            lambda k, L, bk: L @ (2 * bk),  # alpha(k)
+            lambda k: 2 * k,  # beta(k)
+            lambda L, bk: L @ (2 * bk)  # phi1(L)
+        ]
+    else:
+        clenshaw_funcs = [
+            lambda k, L, bk: L @ bk,  # alpha(k)
+            lambda k: k,  # beta(k)
+            lambda L, bk: L @ bk  # phi1(L)
+        ]
 
     return LazyLinOp(
         shape=L.shape,
-        matmat=lambda x: _matmat(L, x, c),
-        rmatmat=lambda x: _matmat(L.T.conj(), x, c)
+        matmat=lambda x: _matmat_clenshaw(L, c, x, *clenshaw_funcs),
+        rmatmat=lambda x: _matmat_clenshaw(L.T.conj(), c, x, *clenshaw_funcs)
     )
 
 
-def lagval(L, c):
+def _lagval(L, c):
     r"""Constructs a :py:class:`.LazyLinOp` Laguerre polynomial ``P(L)``
     of linear operator ``L``.
 
-    ``P(L)`` is equal to :math:`c_0Id + c_1L_{a,1}(L) + \cdots + c_nL_{a,n}(L)`.
+    ``P(L)`` is equal to :math:`c_0Id+c_1L_{a,1}(L)+\cdots+c_nL_{a,n}(L)`.
 
     The k-th Laguerre polynomial can be computed by recurrence:
 
     .. math::
 
         \begin{eqnarray}
         L_{a,0}(L) &=& Id\\
@@ -805,435 +1264,684 @@
 
     The Clenshaw's method is used to compute ``P(L) @ X``.
 
     ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
 
 
     Args:
-        L: 2d array
-            Linear operator.
+        L: LazyLinOp
+            Linear operator (matrix representation must be square).
         c: 1d array
             List of Laguerre polynomial(s) coefficients.
             If the size of the 1d array is n + 1 then the largest power
             of the polynomial is n.
 
     Returns:
         LazyLinOp
 
     Raises:
         Exception
             Matrix representation of L is not square.
-        ValueError
-            L @ x does not work because # of columns of L is not equal to the
-            # of rows of x.
-        ValueError
+        Exception
             List of coefficients has zero size.
+        Exception
+            coef must be a 1d array.
 
     Examples:
         >>> import numpy as np
         >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import lagval
+        >>> from lazylinop.wip.polynomial import _lagval
         >>> x = np.array([1.0, 0.0, 0.0])
         >>> L = eye(3, n=3, k=0)
-        >>> y = lagval(L, [1.0, 2.0, 3.0]) @ x
+        >>> y = _lagval(L, [1.0, 2.0, 3.0]) @ x
         >>> z = np.polynomial.laguerre.lagval(x[0], [1.0, 2.0, 3.0])
         >>> np.allclose(y[0], z)
         True
 
     .. seealso::
         - `Wikipedia <https://en.wikipedia.org/wiki/Laguerre_polynomials>`_,
         - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
           reference/generated/numpy.polynomial.laguerre.lagval.html>`_.
     """
 
     if L.shape[0] != L.shape[1]:
         raise Exception("Matrix representation of L is not square.")
 
-    if type(c) is list:
-        c = np.asarray(c)
+    c = np.asarray(c)
+
+    if c.ndim != 1:
+        raise Exception("coef must be a 1d array.")
 
-    if c.ndim == 2:
-        # Only one polynomial
-        c = np.copy(c[:, 0].flatten())
     D = c.shape[0]
     if D == 0:
-        raise ValueError("List of coefficients has zero size.")
+        raise Exception("List of coefficients has zero size.")
+
+    clenshaw_funcs = [
+        lambda k, L, bk: ((2 * k + 1) * bk - L @ bk) / (k + 1),  # alpha(k)
+        lambda k: k / (k + 1),  # beta(k)
+        lambda L, bk: bk - L @ bk  # phi1(L)
+                     ]
+
+    return LazyLinOp(
+        shape=L.shape,
+        matmat=lambda x: _matmat_clenshaw(L, c, x, *clenshaw_funcs),
+        rmatmat=lambda x: _matmat_clenshaw(L.T.conj(), c, x, *clenshaw_funcs)
+    )
+
+
+def _legval(L, c):
+    r"""Constructs a :py:class:`.LazyLinOp` Legendre polynomial ``P(L)``
+    of linear operator ``L``.
+
+    ``P(L)`` is equal to :math:`c_0Id+c_1L_{e,1}(L)+\cdots+c_nL_{e,n}(L)`.
+
+    The k-th Legendre polynomial can be computed by recurrence:
+
+    .. math::
+
+        \begin{eqnarray}
+        L_{e,0}(L) &=& Id\\
+        L_{e,1}(L) &=& L\\
+        L_{e,k+1}(L) &=& \frac{(2k + 1)LL_{e,k}(L) - kL_{e,k-1}(L)}{k + 1}
+        \end{eqnarray}
+
+    The Clenshaw's method is used to compute ``P(L) @ X``.
+
+    ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
+
+
+    Args:
+        L: LazyLinOp
+            Linear operator (matrix representation must be square).
+        c: 1d array
+            List of Legendre polynomial(s) coefficients.
+            If the size of the 1d array is n + 1 then the largest power
+            of the polynomial is n.
+
+    Returns:
+        LazyLinOp
+
+    Raises:
+        Exception
+            Matrix representation of L is not square.
+        Exception
+            List of coefficients has zero size.
+        Exception
+            coef must be a 1d array.
+
+    Examples:
+        >>> import numpy as np
+        >>> from lazylinop import eye
+        >>> from lazylinop.wip.polynomial import _legval
+        >>> x = np.random.randn(3)
+        >>> L = eye(3, n=3, k=0)
+        >>> y = _legval(L, [1.0, 2.0, 3.0]) @ x
+        >>> z = np.polynomial.laguerre.legval(x[0], [1.0, 2.0, 3.0])
+        >>> np.allclose(y[0], z)
+        True
+
+    .. seealso::
+        - `Wikipedia <https://en.wikipedia.org/wiki/Legendre_polynomials>`_,
+        - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
+          reference/generated/numpy.polynomial.legendre.legval.html>`_.
+    """
+
+    if L.shape[0] != L.shape[1]:
+        raise Exception("Matrix representation of L is not square.")
+
+    c = np.asarray(c)
+
+    if c.ndim != 1:
+        raise Exception("coef must be a 1d array.")
+
+    D = c.shape[0]
+    if D == 0:
+        raise Exception("List of coefficients has zero size.")
+
+    clenshaw_funcs = [
+        lambda k, L, bk: L @ ((2 * k + 1) / (k + 1) * bk),  # alpha(k)
+        lambda k:  k / (k + 1),  # beta(k)
+        lambda L, bk: L @ bk  # phi1(L)
+    ]
+
+    return LazyLinOp(
+        shape=L.shape,
+        matmat=lambda x: _matmat_clenshaw(L, c, x, *clenshaw_funcs),
+        rmatmat=lambda x: _matmat_clenshaw(L.T.conj(), c, x, *clenshaw_funcs)
+    )
+
+
+def _matmat_clenshaw(L, c, x, alpha_func, beta_func, phi1_func):
+    """
+    Clenshaw evaluation of P(L) @ x for any kind of polynomial.
+
+    Args:
+        L: (:py:class:`.LazyLinOp`)
+            linear operator
+        c: (``np.ndarray``)
+            coefficients of the polynomial as a 1d-array.
+        x: (``np.ndarray``)
+            The array to multiply P(L) by.
+        alpha_func:
+            The function alpha(k, L, bk') that computes alpha(k, L) @ bk'
+            (alpha(k, L) is generally alpha(k) * L except for Laguerre).
+        beta_func:
+            The function (- beta(k)).
+        phi1_func:
+            The function phi1(L, bk) that computes phi1(L) @ bk.
+    """
+
+    if x.ndim == 1:
+        is_1d = True
+        x = x.reshape(x.shape[0], 1)
+    else:
+        is_1d = False
+    if c.shape[0] == 1:
+        return (c[0] * x).ravel() if is_1d else c[0] * x
+    elif c.shape[0] == 2:
+        y = c[0] * x + c[1] * phi1_func(L, x)
+        return y.ravel() if is_1d else y
+    else:
+        # Clenshaw algorithm
+        # alpha_k = alpha_func(k) * L
+        # beta_k  = beta_func(k)
+        # phi0 = eye(N, n=N)
+        # phi1 = L
+        # phi_{k + 1} = alpha_k * phi_k + beta_k * phi_{k - 1}
+        # b_k = c_k + alpha_k * b_{k + 1} + beta_{k + 1} * b_{k + 2}
+        # p(L) = phi_0 * c_0 + phi_1 * b_1 + beta_1 * phi_0 * b_2
+        b2 = c[-1] * x
+        b1 = c[-2] * x + alpha_func(len(c) - 2, L, b2)
+        for k in range(c.shape[0] - 3, 0, -1):
+            bk = (
+                c[k] * x +
+                alpha_func(k, L, b1) -
+                ((beta_func(k + 1) * b2) if beta_func(k + 1) != 1 else b2)
+            )
+            b2 = b1
+            b1 = bk
+        # phi0 is always 1/Id
+        y = c[0] * x + phi1_func(L, b1) - (
+            (beta_func(1) * b2) if beta_func(1) != 1 else b2)
+        return y.ravel() if is_1d else y
+
+
+def _rchebval(L, c):
+    r"""Constructs a :py:class:`.LazyLinOp` Chebysev polynomial ``P(L)`` of
+    linear operator ``L``.
+
+    ``P(L)`` is equal to :math:`c_0Id+c_1T_1(L)+\cdots +c_nT_n(L)`.
+
+    The k-th Chebyshev polynomial can be computed by recurrence:
+
+    .. math::
+
+        \begin{eqnarray}
+        T_0(L) &=& 1\\
+        T_1(L) &=& L\\
+        T_{k+1}(L) &=& 2LT_k(L) - T_{k-1}(L)
+        \end{eqnarray}
+
+    ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
+
+
+    Args:
+        L: LazyLinOp
+            Linear operator (matrix representation must be square).
+        c: 1d array
+            List of Chebyshev polynomial(s) coefficients.
+            If the size of the 1d array is n + 1 then the largest power of the
+            polynomial is n.
+
+    Returns:
+        LazyLinOp
+
+    Raises:
+        Exception
+            Matrix representation of L is not square.
+        Exception
+            List of coefficients has zero size.
+        Exception
+            coef must be a 1d array.
+
+    Examples:
+        >>> import numpy as np
+        >>> from lazylinop import eye
+        >>> from lazylinop.wip.polynomial import _rchebval
+        >>> x = np.random.randn(3)
+        >>> L = eye(3, n=3, k=0)
+        >>> y = _rchebval(L, [1.0, 2.0, 3.0]) @ x
+        >>> np.allclose(6.0 * x, y)
+        True
+
+    .. seealso::
+        - `Wikipedia <https://en.wikipedia.org/wiki/Chebyshev_polynomials>`_,
+        - `Polynomial magic web page
+          <https://francisbach.com/chebyshev-polynomials/>`_,
+        - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
+          reference/generated/numpy.polynomial.chebyshev.chebval.html>`_.
+    """
+
+    if L.shape[0] != L.shape[1]:
+        raise Exception("Matrix representation of L is not square.")
+
+    c = np.asarray(c)
+
+    D = c.shape[0]
+    if D == 0:
+        raise Exception("List of coefficients has zero size.")
+
+    if c.ndim != 1:
+        raise Exception("coef must be a 1d array.")
 
     def _matmat(L, x, c):
-        if L.shape[1] != x.shape[0]:
-            raise ValueError("L @ x does not work because # of columns of L is"
-                             " not equal to the # of rows of x.")
         if x.ndim == 1:
             is_1d = True
             x = x.reshape(x.shape[0], 1)
         else:
             is_1d = False
         batch_size = x.shape[1]
-        output = np.empty((L.shape[0], batch_size),
-                          dtype=binary_dtype(c.dtype, x.dtype))
-        La0x = np.empty((L.shape[0], batch_size),
-                       dtype=binary_dtype(c.dtype, x.dtype))
-        La1x = np.empty((L.shape[0], batch_size),
+        T0x = np.copy(x)
+        T1x = np.empty((L.shape[0], batch_size),
                        dtype=binary_dtype(c.dtype, x.dtype))
-        La2x = np.empty((L.shape[0], batch_size),
+        T2x = np.empty((L.shape[0], batch_size),
                        dtype=binary_dtype(c.dtype, x.dtype))
-        np.copyto(La0x, x)
-        np.copyto(output[:, :], np.multiply(c[0], La0x))
+        output = np.multiply(c[0], T0x)
         if D > 1:
             # loop over the coefficients
             for i in range(1, D):
                 if i == 1:
-                    np.copyto(La1x, np.subtract(x, L @ x))
-                    if c[i] == 0.0:
-                        continue
-                    else:
-                        np.add(output, np.multiply(c[i], La1x), out=output)
+                    np.copyto(T1x, L @ x)
+                    if c[i] != 0.0:
+                        np.add(output, np.multiply(c[i], T1x), out=output)
                 else:
-                    np.copyto(La2x, np.divide(
-                        np.subtract(
-                            np.subtract(
-                                np.multiply(2.0 * (i - 1) + 1.0, La1x),
-                                L @ La1x),
-                            np.multiply(i - 1, La0x)), i))
+                    np.copyto(T2x, np.subtract(np.multiply(2.0, L @ T1x), T0x))
                     # Recurrence
-                    np.copyto(La0x, La1x)
-                    np.copyto(La1x, La2x)
-                    if c[i] == 0.0:
-                        continue
-                    else:
-                        np.add(output, np.multiply(c[i], La2x), out=output)
+                    np.copyto(T0x, T1x)
+                    np.copyto(T1x, T2x)
+                    if c[i] != 0.0:
+                        np.add(output, np.multiply(c[i], T2x), out=output)
         return output.ravel() if is_1d else output
 
     return LazyLinOp(
         shape=L.shape,
         matmat=lambda x: _matmat(L, x, c),
         rmatmat=lambda x: _matmat(L.T.conj(), x, c)
     )
 
 
-def legval(L, c):
-    r"""Constructs a :py:class:`.LazyLinOp` Legendre polynomial ``P(L)``
-    of linear operator ``L``.
+def _rhermval(L, c, physicist: bool = True):
+    r"""Constructs a :py:class:`.LazyLinOp` Hermite (physicist or
+    probabilistic) polynomial ``P(L)`` of linear operator ``L``.
 
-    ``P(L)`` is equal to :math:`c_0Id + c_1L_{e,1}(L) + \cdots + c_nL_{e,n}(L)`.
+    ``P(L)`` is equal to :math:`c_0Id+c_1H_1(L)+\cdots +c_nH_n(L)`.
 
-    The k-th Legendre polynomial can be computed by recurrence:
+    The k-th Hermite (physicist) polynomial can be computed by recurrence:
 
     .. math::
 
         \begin{eqnarray}
-        L_{e,0}(L) &=& Id\\
-        L_{e,1}(L) &=& L\\
-        L_{e,k+1}(L) &=& \frac{(2k + 1)LL_{e,k}(L) - kL_{e,k-1}(L)}{k + 1}
+        H_0(L) &=& Id\\
+        H_1(L) &=& 2L\\
+        H_{k+1}(L) &=& 2LH_k(L) - 2kH_{k-1}(L)
         \end{eqnarray}
 
-    The Clenshaw's method is used to compute ``P(L) @ X``.
+    The k-th Hermite (probabilist) polynomial can be computed by recurrence:
+
+    .. math::
+
+        \begin{eqnarray}
+        H_0(L) &=& Id\\
+        H_1(L) &=& L\\
+        H_{k+1}(L) &=& LH_k(L) - kH_{k-1}(L)
+        \end{eqnarray}
 
     ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
 
 
     Args:
-        L: 2d array
-            Linear operator.
+        L: LazyLinOp
+            Linear operator (matrix representation must be square).
         c: 1d array
-            List of Legendre polynomial(s) coefficients.
-            If the size of the 1d array is n + 1 then the largest power
-            of the polynomial is n.
+            List of Hermite (physicist) polynomial(s) coefficients.
+            If the size of the 1d array is n + 1 then the largest power of the
+            polynomial is n.
+        physicist: bool, optional
+            If True (default) construct Hermite "physicist" polynomial.
+            If False construct Hermite "probabilistic" polynomial.
 
     Returns:
         LazyLinOp
 
     Raises:
         Exception
             Matrix representation of L is not square.
-        ValueError
-            L @ x does not work because # of columns of L is not equal to the
-            # of rows of x.
-        ValueError
+        Exception
             List of coefficients has zero size.
+        Exception
+            coef must be a 1d array.
 
     Examples:
         >>> import numpy as np
         >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import legval
-        >>> x = np.random.randn(3)
+        >>> from lazylinop.wip.polynomial import _hermval
+        >>> x = np.array([1.0, 0.0, 0.0])
         >>> L = eye(3, n=3, k=0)
-        >>> y = legval(L, [1.0, 2.0, 3.0]) @ x
-        >>> np.allclose(6.0 * x, y)
+        >>> y = _hermval(L, [1.0, 2.0, 3.0]) @ x
+        >>> z = np.polynomial.hermite.hermval(x[0], [1.0, 2.0, 3.0])
+        >>> np.allclose(y[0], z)
         True
 
     .. seealso::
-        - `Wikipedia <https://en.wikipedia.org/wiki/Legendre_polynomials>`_,
+        - `Wikipedia <https://en.wikipedia.org/wiki/Hermite_polynomials>`_,
         - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
-          reference/generated/numpy.polynomial.legendre.legval.html>`_.
+          reference/generated/numpy.polynomial.hermite.hermval.html>`_.
     """
 
     if L.shape[0] != L.shape[1]:
         raise Exception("Matrix representation of L is not square.")
 
-    if type(c) is list:
-        c = np.asarray(c)
+    c = np.asarray(c)
 
-    if c.ndim == 2:
-        # Only one polynomial
-        c = np.copy(c[:, 0].flatten())
     D = c.shape[0]
     if D == 0:
-        raise ValueError("List of coefficients has zero size.")
+        raise Exception("List of coefficients has zero size.")
+
+    if c.ndim != 1:
+        raise Exception("coef must be a 1d array.")
 
     def _matmat(L, x, c):
-        if L.shape[1] != x.shape[0]:
-            raise ValueError("L @ x does not work because # of columns of L is"
-                             " not equal to the # of rows of x.")
         if x.ndim == 1:
             is_1d = True
             x = x.reshape(x.shape[0], 1)
         else:
             is_1d = False
         batch_size = x.shape[1]
-        output = np.empty((L.shape[0], batch_size),
-                          dtype=binary_dtype(c.dtype, x.dtype))
-        Le0x = np.empty((L.shape[0], batch_size),
+        H0x = np.empty((L.shape[0], batch_size),
                        dtype=binary_dtype(c.dtype, x.dtype))
-        Le1x = np.empty((L.shape[0], batch_size),
+        H1x = np.empty((L.shape[0], batch_size),
                        dtype=binary_dtype(c.dtype, x.dtype))
-        Le2x = np.empty((L.shape[0], batch_size),
+        H2x = np.empty((L.shape[0], batch_size),
                        dtype=binary_dtype(c.dtype, x.dtype))
-        np.copyto(Le0x, x)
-        np.copyto(output[:, :], np.multiply(c[0], Le0x))
+        np.copyto(H0x, x)
+        output = np.multiply(c[0], H0x)
         if D > 1:
             # loop over the coefficients
-            for i in range(1, D):
-                if i == 1:
-                    np.copyto(Le1x, L @ x)
-                    if c[i] == 0.0:
-                        continue
+            if physicist:
+                for i in range(1, D):
+                    if i == 1:
+                        np.copyto(H1x, np.multiply(2.0, L @ x))
+                        if c[i] != 0.0:
+                            np.add(output, np.multiply(c[i], H1x), out=output)
                     else:
-                        np.add(output, np.multiply(c[i], Le1x), out=output)
-                else:
-                    np.copyto(Le2x, np.divide(
-                        np.subtract(
-                            np.multiply(2.0 * (i - 1) + 1.0, L @ Le1x),
-                            np.multiply(i - 1, Le0x)), i))
-                    # Recurrence
-                    np.copyto(Le0x, Le1x)
-                    np.copyto(Le1x, Le2x)
-                    if c[i] == 0.0:
-                        continue
+                        np.copyto(H2x,
+                                  np.subtract(np.multiply(2.0, L @ H1x),
+                                              np.multiply(2 * (i - 1), H0x)))
+                        # Recurrence
+                        np.copyto(H0x, H1x)
+                        np.copyto(H1x, H2x)
+                        if c[i] != 0.0:
+                            np.add(output, np.multiply(c[i], H2x), out=output)
+            else:
+                for i in range(1, D):
+                    if i == 1:
+                        np.copyto(H1x, L @ x)
+                        if c[i] != 0.0:
+                            np.add(output, np.multiply(c[i], H1x), out=output)
                     else:
-                        np.add(output, np.multiply(c[i], Le2x), out=output)
+                        np.copyto(H2x, np.subtract(L @ H1x,
+                                                   np.multiply(i - 1, H0x)))
+                        # Recurrence
+                        np.copyto(H0x, H1x)
+                        np.copyto(H1x, H2x)
+                        if c[i] != 0.0:
+                            np.add(output, np.multiply(c[i], H2x), out=output)
         return output.ravel() if is_1d else output
 
     return LazyLinOp(
         shape=L.shape,
         matmat=lambda x: _matmat(L, x, c),
         rmatmat=lambda x: _matmat(L.T.conj(), x, c)
     )
 
 
-def polyval(L, c):
-    r"""Constructs a :py:class:`.LazyLinOp` polynomial ``P(L)`` of linear
-    operator ``L``.
+def _rlagval(L, c):
+    r"""Constructs a :py:class:`.LazyLinOp` Laguerre polynomial ``P(L)``
+    of linear operator ``L``.
+
+    ``P(L)`` is equal to :math:`c_0Id+c_1L_{a,1}(L)+\cdots+c_nL_{a,n}(L)`.
 
-    ``P(L)`` is equal to :math:`c_0Id + c_1L^1 + \cdots + c_nL^n`.
+    The k-th Laguerre polynomial can be computed by recurrence:
+
+    .. math::
+
+        \begin{eqnarray}
+        L_{a,0}(L) &=& Id\\
+        L_{a,1}(L) &=& Id - L\\
+        L_{a,k+1}(L) &=& \frac{(2k + 1 - L)L_{a,k}(L) - kL_{a,k-1}(L)}{k + 1}
+        \end{eqnarray}
 
     ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
 
+
     Args:
-        L: 2d array
-            Linear operator.
+        L: LazyLinOp
+            Linear operator (matrix representation must be square).
         c: 1d array
-            List of polynomial coefficients.
-            If the size of the 1d array is n + 1 then the largest power of the
-            polynomial is n.
-            If the array is 2d consider only the first column/polynomial.
+            List of Laguerre polynomial(s) coefficients.
+            If the size of the 1d array is n + 1 then the largest power
+            of the polynomial is n.
 
     Returns:
         LazyLinOp
 
     Raises:
         Exception
             Matrix representation of L is not square.
-        ValueError
-            L @ x does not work because # of columns of L is not equal to the
-            # of rows of x.
-        ValueError
+        Exception
             List of coefficients has zero size.
+        Exception
+            coef must be a 1d array.
 
     Examples:
         >>> import numpy as np
         >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import polyval
-        >>> x = np.random.randn(3)
+        >>> from lazylinop.wip.polynomial import _rlagval
+        >>> x = np.array([1.0, 0.0, 0.0])
         >>> L = eye(3, n=3, k=0)
-        >>> y = polyval(L, [1.0, 2.0, 3.0]) @ x
-        >>> np.allclose(6.0 * x, y)
+        >>> y = _rlagval(L, [1.0, 2.0, 3.0]) @ x
+        >>> z = np.polynomial.laguerre.lagval(x[0], [1.0, 2.0, 3.0])
+        >>> np.allclose(y[0], z)
         True
 
     .. seealso::
+        - `Wikipedia <https://en.wikipedia.org/wiki/Laguerre_polynomials>`_,
         - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
-          reference/generated/numpy.polynomial.polynomial.polyval.html>`_.
-        - :py:func:`polyvalfromroots`.
+          reference/generated/numpy.polynomial.laguerre.lagval.html>`_.
     """
 
     if L.shape[0] != L.shape[1]:
         raise Exception("Matrix representation of L is not square.")
 
-    if type(c) is list:
-        c = np.asarray(c)
+    c = np.asarray(c)
+
+    if c.ndim != 1:
+        raise Exception("coef must be a 1d array.")
 
-    if c.ndim == 2:
-        # Only one polynomial
-        c = np.copy(c[:, 0].flatten())
     D = c.shape[0]
     if D == 0:
-        raise ValueError("List of coefficients has zero size.")
+        raise Exception("List of coefficients has zero size.")
 
     def _matmat(L, x, c):
-        if L.shape[1] != x.shape[0]:
-            raise ValueError("L @ x does not work because # of columns of L is"
-                             " not equal to the # of rows of x.")
-        # x can't be a LazyLinOp here because it's handle before in
-        # LazyLinOp.__matmul__
         if x.ndim == 1:
             is_1d = True
             x = x.reshape(x.shape[0], 1)
         else:
             is_1d = False
-        output = np.empty((L.shape[0], x.shape[1]),
-                          dtype=binary_dtype(c.dtype, x.dtype))
-        Lx = np.empty((L.shape[0], x.shape[1]), dtype=binary_dtype(c.dtype,
-                                                                   x.dtype))
-        output[:, :] = np.multiply(c[0], x)
+        batch_size = x.shape[1]
+        La0x = np.empty((L.shape[0], batch_size),
+                        dtype=binary_dtype(c.dtype, x.dtype))
+        La1x = np.empty((L.shape[0], batch_size),
+                        dtype=binary_dtype(c.dtype, x.dtype))
+        La2x = np.empty((L.shape[0], batch_size),
+                        dtype=binary_dtype(c.dtype, x.dtype))
+        np.copyto(La0x, x)
+        output = np.multiply(c[0], La0x)
         if D > 1:
-            # Loop over the coefficients
+            # loop over the coefficients
             for i in range(1, D):
                 if i == 1:
-                    np.copyto(Lx, L @ x)
-                else:
-                    np.copyto(Lx, L @ Lx)
-                if c[i] == 0.0:
-                    continue
+                    np.copyto(La1x, np.subtract(x, L @ x))
+                    if c[i] != 0.0:
+                        np.add(output, np.multiply(c[i], La1x), out=output)
                 else:
-                    np.add(output[:, :], np.multiply(c[i], Lx), out=output)
+                    np.copyto(La2x, np.divide(
+                        np.subtract(
+                            np.subtract(
+                                np.multiply(2.0 * (i - 1) + 1.0, La1x),
+                                L @ La1x),
+                            np.multiply(i - 1, La0x)), i))
+                    # Recurrence
+                    np.copyto(La0x, La1x)
+                    np.copyto(La1x, La2x)
+                    if c[i] != 0.0:
+                        np.add(output, np.multiply(c[i], La2x), out=output)
         return output.ravel() if is_1d else output
 
     return LazyLinOp(
         shape=L.shape,
         matmat=lambda x: _matmat(L, x, c),
         rmatmat=lambda x: _matmat(L.T.conj(), x, c)
     )
 
 
-def polyvalfromroots(L, r):
-    r"""Constructs a :py:class:`.LazyLinOp` polynomial
-    ``P(L)`` of linear operator ``L`` from the polynomial roots.
+def _rlegval(L, c):
+    r"""Constructs a :py:class:`.LazyLinOp` Legendre polynomial ``P(L)``
+    of linear operator ``L``.
 
-    ``P(L)`` is equal to :math:`(L - r_0Id)(L - r_1)\cdots (L - r_nId)`.
+    ``P(L)`` is equal to :math:`c_0Id+c_1L_{e,1}(L)+\cdots+c_nL_{e,n}(L)`.
+
+    The k-th Legendre polynomial can be computed by recurrence:
+
+    .. math::
+
+        \begin{eqnarray}
+        L_{e,0}(L) &=& Id\\
+        L_{e,1}(L) &=& L\\
+        L_{e,k+1}(L) &=& \frac{(2k + 1)LL_{e,k}(L) - kL_{e,k-1}(L)}{k + 1}
+        \end{eqnarray}
 
     ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
 
+
     Args:
-        L: 2d array
-            Linear operator.
-        r: 1d array
-            List of polynomial roots.
-            If the size of the 1d array is n + 1 then the largest power of the
-            polynomial is n.
-            If the array is 2d, the function considers only the first
-            column/polynomial.
+        L: LazyLinOp
+            Linear operator (matrix representation must be square).
+        c: 1d array
+            List of Legendre polynomial(s) coefficients.
+            If the size of the 1d array is n + 1 then the largest power
+            of the polynomial is n.
 
     Returns:
         LazyLinOp
 
     Raises:
         Exception
             Matrix representation of L is not square.
-        ValueError
-            L @ x does not work because # of columns of L is not equal to the #
-            of rows of x.
-        ValueError
-            List of roots has zero size.
+        Exception
+            List of coefficients has zero size.
+        Exception
+            coef must be a 1d array.
 
     Examples:
         >>> import numpy as np
         >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import polyvalfromroots
+        >>> from lazylinop.wip.polynomial import _legval
         >>> x = np.random.randn(3)
         >>> L = eye(3, n=3, k=0)
-        >>> y = polyvalfromroots(L, [1.0, 1.0, 1.0]) @ x
-        >>> np.allclose(0.0 * x, y)
+        >>> y = _legval(L, [1.0, 2.0, 3.0]) @ x
+        >>> z = np.polynomial.laguerre.legval(x[0], [1.0, 2.0, 3.0])
+        >>> np.allclose(y[0], z)
         True
 
     .. seealso::
-        - `NumPy polynomial class <https://docs.scipy.org/doc/
-          numpy-1.9.3/reference/generated/numpy.polynomial.polynomial.
-          polyval.html>`_.
-        - :py:func:`polyval`.
+        - `Wikipedia <https://en.wikipedia.org/wiki/Legendre_polynomials>`_,
+        - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
+          reference/generated/numpy.polynomial.legendre.legval.html>`_.
     """
 
     if L.shape[0] != L.shape[1]:
         raise Exception("Matrix representation of L is not square.")
 
-    if type(r) is list:
-        r = np.asarray(r)
+    c = np.asarray(c)
 
-    if r.ndim == 2:
-        # Only one polynomial
-        r = np.copy(r[:, 0].flatten())
-    R = r.shape[0]
-    if R == 0:
-        raise ValueError("List of roots has zero size.")
+    if c.ndim != 1:
+        raise Exception("coef must be a 1d array.")
+
+    D = c.shape[0]
+    if D == 0:
+        raise Exception("List of coefficients has zero size.")
 
-    def _matmat(r, L, x):
-        if L.shape[1] != x.shape[0]:
-            raise ValueError("L @ x does not work because # of columns of L is"
-                             " not equal to the # of rows of x.")
+    def _matmat(L, x, c):
         if x.ndim == 1:
             is_1d = True
             x = x.reshape(x.shape[0], 1)
         else:
             is_1d = False
-        output = np.empty((L.shape[0], x.shape[1]),
-                          dtype=binary_dtype(r.dtype,
-                                             x.dtype))
-        Lx = np.empty((L.shape[0], x.shape[1]), dtype=binary_dtype(r.dtype,
-                                                                   x.dtype))
-        if r[R - 1] == 0.0:
-            np.copyto(Lx, L @ x)
-        else:
-            np.copyto(Lx, np.subtract(L @ x, np.multiply(r[R - 1], x)))
-        if R > 1:
-            for i in range(1, R):
-                if r[R - 1 - i] == 0.0:
-                    np.copyto(Lx, L @ Lx)
+        batch_size = x.shape[1]
+        Le0x = np.empty((L.shape[0], batch_size),
+                        dtype=binary_dtype(c.dtype, x.dtype))
+        Le1x = np.empty((L.shape[0], batch_size),
+                        dtype=binary_dtype(c.dtype, x.dtype))
+        Le2x = np.empty((L.shape[0], batch_size),
+                        dtype=binary_dtype(c.dtype, x.dtype))
+        np.copyto(Le0x, x)
+        output = np.multiply(c[0], Le0x)
+        if D > 1:
+            # loop over the coefficients
+            for i in range(1, D):
+                if i == 1:
+                    np.copyto(Le1x, L @ x)
+                    if c[i] != 0.0:
+                        np.add(output, np.multiply(c[i], Le1x), out=output)
                 else:
-                    np.copyto(Lx, np.subtract(L @ Lx, np.multiply(r[R - 1 - i],
-                                                                  Lx)))
-        np.copyto(output[:, :], Lx)
+                    np.copyto(Le2x, np.divide(
+                        np.subtract(
+                            np.multiply(2.0 * (i - 1) + 1.0, L @ Le1x),
+                            np.multiply(i - 1, Le0x)), i))
+                    # Recurrence
+                    np.copyto(Le0x, Le1x)
+                    np.copyto(Le1x, Le2x)
+                    if c[i] != 0.0:
+                        np.add(output, np.multiply(c[i], Le2x), out=output)
         return output.ravel() if is_1d else output
 
     return LazyLinOp(
         shape=L.shape,
-        matmat=lambda x: _matmat(r, L, x),
-        rmatmat=lambda x: _matmat(r, L.T.conj(), x)
+        matmat=lambda x: _matmat(L, x, c),
+        rmatmat=lambda x: _matmat(L.T.conj(), x, c)
     )
 
 
 def power(L, n):
-    r"""Constructs the n-th power :math:`L^n` of linear operator ``L``.
+    r"""Constructs the n-th power :math:`L^n` of linear operator :math:`L`.
+    Matrix representation of :math:`L` must be square.
+    :octicon:`alert-fill;1em;sd-text-danger` In some cases
+    :code:`power(L,n) @ x` can be least efficient than
+    :code:`M=np.power(L.toarray()) @ x`.
 
     .. note::
-        It is equivalent to create a :py:class:`poly` instance such that
-        only n-th coefficient is equal to one while the others are equal
-        to zero.
+        It is equivalent to create an instance from
+        :py:func:`xpoly(coef, kind)` such that only n-th coefficient
+        is equal to one while the others are equal to zero.
 
     Args:
-        L: 2d array
+        L: LazyLinOp
             Linear operator (e.g. a :py:class:`.LazyLinOp`).
+            Matrix representation must be square.
         n: int
             Raise the linear operator to degree n.
             If n is zero, return identity matrix.
 
     Returns:
         LazyLinOp :math:`L^n`.
 
@@ -1257,35 +1965,12 @@
         >>> np.allclose(L @ x, np.zeros(3, dtype=np.float_))
         True
 
     .. seealso::
         `NumPy power function
         <https://numpy.org/doc/stable/reference/generated/numpy.power.html>`_.
     """
+    return aslazylinop(L)**n
 
-    if n < 0:
-        raise ValueError("n must be > 0.")
-
-    if L.shape[0] != L.shape[1]:
-        raise Exception("Matrix representation of L is not square.")
-
-    if n == 0:
-        from lazylinop import eye
-        return eye(L.shape[0], n=L.shape[1], k=0)
-
-    def _matmat(L, n, x):
-        output = L @ x
-        if n > 1:
-            for n in range(1, n):
-                np.copyto(output, L @ output)
-        return output
-
-    return LazyLinOp(
-        shape=L.shape,
-        matmat=lambda x: _matmat(L, n, x),
-        rmatmat=lambda x: _matmat(L.T.conj(), n, x)
-    )
-
-
-if __name__ == '__main__':
-    import doctest
-    doctest.testmod()
+# if __name__ == '__main__':
+#     import doctest
+#     doctest.testmod()
```

## lazylinop/wip/linalg/cosm.py

```diff
@@ -47,32 +47,31 @@
         >>> E3 = eye(N, n=N, k=0)
         >>> X = np.random.rand(N, 2 * N)
         >>> np.allclose(E2 @ X, E3 @ X)
 
     References:
         See also `scipy.linalg.cosm function <https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cosm.html>`_.
         See also :py:func:`expm`.
-        See also :py:func:`lazylinop.wip.polynomial.polyval`.
     """
     if backend == 'scipy':
         if islazylinop(L):#type(L) is np.ndarray:
             raise ValueError("If L is a 2d array, backend must be 'scipy'.")
         return LazyLinOp(
             shape=L.shape,
             matmat=lambda X: sp.linalg.cosm(scale * L) @ X,
             rmatmat=lambda X: sp.linalg.cosm(scale * L.T.conj()) @ X
         )
     elif backend == 'serie':
-        from lazylinop.wip.polynomial import polyval
+        from lazylinop.wip.polynomial import _polyval
         coefficients = np.empty(nmax + 1, dtype=np.float64)
         factor = 1.0
         sign = 1
         for i in range(nmax + 1):
             if (i % 2) == 0:
                 coefficients[i] = sign * factor
                 sign *= -1
             else:
                 coefficients[i] = 0.0
             factor *= scale / (i + 1)
-        return polyval(L, coefficients)
+        return _polyval(L, coefficients)
     else:
         raise ValueError("backend value is either 'scipy' or 'serie'.")
```

## lazylinop/wip/linalg/expm.py

```diff
@@ -49,15 +49,14 @@
         >>> np.allclose(E1.toarray(), E2)
         >>> E3 = eye(N, n=N, k=0)
         >>> X = np.random.rand(N, 2 * N)
         >>> np.allclose(E2 @ X, E3 @ X)
 
     References:
         See also `scipy.linalg.expm function <https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.expm.html>`_.
-        See also :py:func:`lazylinop.wip.polynomial.polyval`.
     """
     if backend == 'scipy':
         if islazylinop(L):#type(L) is np.ndarray:
             raise ValueError("If L is a 2d array, backend must be 'scipy'.")
         if use_numba:
             M = sp.linalg.expm(scale * L)
             nb.config.DISABLE_JIT = 0 if use_numba else 1
@@ -93,19 +92,19 @@
             raise ValueError("If L is a 2d array, backend must be 'scipy'.")
         return LazyLinOp(
             shape=L.shape,
             matmat=lambda X: sp.linalg.expm(scale * L) @ X,
             rmatmat=lambda X: sp.linalg.expm(scale * L.T.conj()) @ X
         )
     elif backend == 'serie':
-        from lazylinop.wip.polynomial import polyval
+        from lazylinop.wip.polynomial import _polyval
         coefficients = np.empty(nmax + 1, dtype=np.float64)
         factor = 1.0
         factorial = 1.0
         for i in range(nmax + 1):
             coefficients[i] = factor / factorial
             factor *= scale
             factorial *= (i + 1)
-        return polyval(L, coefficients)
+        return _polyval(L, coefficients)
     else:
         raise ValueError("backend value is either 'scipy' or 'serie'.")
```

## lazylinop/wip/linalg/sinm.py

```diff
@@ -47,34 +47,33 @@
         >>> E3 = eye(N, n=N, k=0)
         >>> X = np.random.rand(N, 2 * N)
         >>> np.allclose(E2 @ X, E3 @ X)
 
     References:
         See also `scipy.linalg.sinm function <https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.sinm.html>`_.
         See also :py:func:`expm`.
-        See also :py:func:`lazylinop.wip.polynomial.polyval`.
     """
     if backend == 'scipy':
         if islazylinop(L):#type(L) is np.ndarray:
             raise ValueError("If L is a 2d array, backend must be 'scipy'.")
         return LazyLinOp(
             shape=L.shape,
             matmat=lambda X: sp.linalg.sinm(scale * L) @ X,
             rmatmat=lambda X: sp.linalg.sinm(scale * L.T.conj()) @ X
         )
     elif backend == 'serie':
-        from lazylinop.wip.polynomial import polyval
+        from lazylinop.wip.polynomial import _polyval
         coefficients = np.empty(nmax + 1, dtype=np.float64)
         factor = 1.0
         sign = 1
         for i in range(nmax + 1):
             if (i % 2) == 1:
                 coefficients[i] = sign * factor
                 sign *= -1
             else:
                 coefficients[i] = 0.0
             factor *= scale / (i + 1)
-        return polyval(L, coefficients)
+        return _polyval(L, coefficients)
     else:
         raise ValueError("backend value is either 'scipy' or 'serie'.")
```

## lazylinop/wip/parallel/mpilop.py

```diff
@@ -63,15 +63,15 @@
             >>> import numpy as np
             >>> M = np.random.rand(*shape)
             >>> np.savez('M.npz', M)
             >>> MPILop(shape, 'M.npz', np.dtype('float64'), bcast_op=False)
             <15x20 MPILop with unspecified dtype>
 
         **See also** bm_np_mul.py_ and bm_mpilop.py_ for valuable examples and
-        the `news <news.html#mpilop>`__.
+        :ref:`mpilop_bench`.
 
         .. _bm_np_mul.py: _static/bm_np_mul.py
         .. _bm_mpilop.py: _static/bm_np_mul.py
         """
         comm = MPI.COMM_WORLD
         rank = comm.Get_rank()
         self.bcast_op = bcast_op
@@ -153,15 +153,15 @@
         size = self.size
         shape = self.shape
 
         slot_inds = self.slot_inds[axis]
         Ls = self.Ls[axis]
 
         if rank > 0 and bcast_op:
-            M = np.empty((shape[(axis+1) % 2], ncols))
+            M = np.empty((shape[(axis+1) % 2], ncols), dtype=Ls.dtype)
 
         if bcast_op:
             comm.Bcast(M, root=0)
         Ls = Ls.reshape(-1, shape[(axis+1) % 2])
         rs = Ls @ M
 
         if rank == 0:
```

## Comparing `lazylinop-1.6.1.dist-info/LICENSE.txt` & `lazylinop-1.7.0.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `lazylinop-1.6.1.dist-info/METADATA` & `lazylinop-1.7.0.dist-info/METADATA`

 * *Files 22% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: lazylinop
-Version: 1.6.1
+Version: 1.7.0
 Summary: A package dedicated to lazy linear operators based on diverse backends/libraries.
 Author-email: Inria <remi.gribonval@inria.fr>, Pascal Carrivain <pascal.carrivain@inria.fr>, Simon Delamare <simon.delamare@ens-lyon.fr>, Hakim Hadj-Djilani <hakim.hadj-djilani@inria.fr>, Rémi Gribonval <remi.gribonval@inria.fr>
 License: Copyright 2023, Inria
         
         BSD License 2.0
         
         Redistribution and use in source and binary forms, with or without
@@ -29,80 +29,135 @@
 Requires-Dist: mpi4py
 
 .. Lazylinop documentation master file, created by
    sphinx-quickstart on Sun Apr  2 17:21:28 2023.
    You can adapt this file completely to your liking, but it should at least
    contain the root `toctree` directive.
 
+.. note Please be warned that this introduction file is shared between the
+   Sphinx doc (Gitlab Pages) and the PyPI project description (pypi.org).
+   Hence it should not contain internal API documentation references as for example
+   :py`.LazyLinOp` but rather online HTTP links. The reason is simple:
+   pypi.org website makes no parsing of any syntax of the sphinx extensions.
+   It understands only raw RST. We could make some pre-filtering to avoid any
+   issue but until then just keep it simple (no internal API reference here).
+
 Lazylinop's documentation
-=====================================
+=========================
 
 Lazylinop philosophy -- what is a LazyLinOp object?
-------------------------------------------------------
+---------------------------------------------------
 
-Starting from a `numpy array`_, a `scipy matrix`_, a Faust_ object, or potentially
-many other compatible linear operators with efficient implementatons, a
-`.LazyLinOp` object follows the lazy evaluation paradigm. In short, one can aggregate
-low-level `.LazyLinOp` objects into higher-level ones using many  classical
-operations (addition, concatenation, adjoint, real part, etc.), without
-actually building arrays. The actual effect of these operations is delayed
-until the resulting linear operator is actually applied to a vector (or to a
-collection of vectors, seen as a matrix).
-
-The main interest of this paradigm is to enable the construction of processing
-pipelines that exploit as building blocks efficient implementations of
-“low-level” linear operators.
+A LazyLinOp_ is a high-level linear operator based on an
+arbitrary underlying implementation, such as:
 
-LazyLinOperators are complementary to other “lazy” objects such as
-LazyTensors_ in Kheops, or the ones of lazyarray_, WeldNumpy_ an pylops_ libraries,
-which, to the best of our knowledge, primarily provide compact descriptions of
-arrays which entries can be evaluated efficiently on the fly.
+    - custom Python functions,
+    - a `NumPy array`_,
+    - a `SciPy matrix`_,
+    - a Faust_ object,
+    - any Python linear operator.
+
+.. voluntarily in long lines to get a new line without a blank line in
+   between
+
+| Thanks to the Lazylinop API, this operator can be easily manipulated, transformed or aggregated with other linear operators to form more complex LazyLinOp_ objects.  Thus, many operations are available such as the addition, concatenation, adjoint etc.
+| These operations are all ruled by the **lazy paradigm**: their evaluation is delayed until the resulting LazyLinOp_ is actually applied to a vector (or to a collection of vectors, seen as a matrix).
+
+Main benefits of Lazylinop
+--------------------------
+
+Lazylinop aims at providing:
+
+    - a unified NumPy/SciPy-like API for any underlying implementation
+      (including transparent use of efficient third-party libraries for
+      advanced linear operators such as wavelets, etc.),
 
-It's worth noting that the way pylops_ exhibits scipy `LinearOperator`-s
-in its API is different. Indeed, pylops_ provides Python classes (like Kronecker_)
-while lazylinop is more likely to propose Python functions in the scipy style (like
-:py`.kron`).
-
-.. Warning:: lazylinop is currently in a beta stage of development. It is
-   thus intensively evolving and we invite you to consult this documentation
-   regularly.
+    - an easy way to combine existing operators into more complex operators
+      with all the LazyLinOp_ operations at your fingertips (and in particular
+      the adjoint),
+
+    - potential performance gains & memory sparing offered by the lazy paradigm,
+
+    - many pre-built operators and related APIs, delivered in specialized
+      Lazylinop sub-packages (polynomials of operators, signal-processing
+      oriented operators, etc.).
+
+    - Compatibility with SciPy algorithms implemented for `LinearOperator-s
+      <https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.
+      linalg.LinearOperator.html>`_: `svds <https://docs.scipy.org/doc/scipy/
+      reference/generated/scipy.sparse.linalg.svds.html#scipy.sparse.linalg
+      .svds>`_, `eigsh <https://docs.scipy.org/doc/scipy/reference/generated/
+      scipy.sparse.linalg.eigsh.html>`_, etc.
+
+Lazylinop is also an alternative or a complement to other related libraries
+that harness the power of the lazy paradigm. See the section
+`Related lazy libraries`_ for more details.
+
+
+.. admonition:: Beta stage
+    admonition warning
+
+   Lazylinop is currently in a beta stage of development. It is thus
+   intensively evolving and we invite you to consult this documentation
+   regularly. We welcome all beta testers and any `feedback
+   <https://gitlab.inria.fr/faustgrp/lazylinop/issues>`_.
 
 .. _Faust: https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/classpyfaust_1_1Faust.html
-.. _numpy array: https://numpy.org/doc/stable/reference/generated/numpy.array.html
-.. _scipy matrix: https://docs.scipy.org/doc/scipy/reference/sparse.html
-.. _LazyTensors: https://www.kernel-operations.io/keops/python/LazyTensor.html
-.. _lazyarray: https://pypi.org/project/lazyarray/
-.. _WeldNumpy: https://www.weld.rs/weldnumpy/
-.. _pylops: https://pylops.readthedocs.io/en/latest/api/index.html
-.. _scipy: https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.kron.html
-.. _Kronecker: https://pylops.readthedocs.io/en/stable/api/generated/pylops.Kronecker.html
+.. _NumPy array: https://numpy.org/doc/stable/reference/generated/numpy.array.html
+.. _SciPy matrix: https://docs.scipy.org/doc/scipy/reference/sparse.html
+.. _LazyLinOp: https://faustgrp.gitlabpages.inria.fr/lazylinop/api_lazylinop.html
+   #lazylinop.LazyLinOp
 
 Getting started with lazylinop
 ------------------------------
 
-**Quick installation**
-
-**Using Anaconda**
+**Quick install using Anaconda**
 ::
 
         conda config --add channels conda-forge
         conda config --add channels pyfaust
         conda config --add channels lazylinop
         conda install lazylinop
 
-or
 
-**Using PIP**
+**Quick install using PIP**
 ::
 
         pip install lazylinop
 
-For a straightforward installation of lazylinop go to this guide_.
-Then for a quick introduction to lazylinop go to this notebook_. The raw notebook is
+Python beginners willing to safely install Lazylinop with a virtual environment can consult this guide_.
+
+**Quick introduction**
+
+For a quick introduction to the use of Lazylinop go to this notebook_. The raw notebook is
 available here_.
 
 .. full links (not relative) because this file is used also in pypi full
    description
 .. _guide: https://faustgrp.gitlabpages.inria.fr/lazylinop/install.html
 .. _notebook: https://faustgrp.gitlabpages.inria.fr/lazylinop/notebooks/lazylinop.html
 .. _here: https://faustgrp.gitlabpages.inria.fr/lazylinop/_static/lazylinop.ipynb
 
+Related lazy libraries
+______________________
+
+`LazyLinOp`_-s are complementary to other “lazy” objects such as
+LazyTensors_ in `KeOps`_, or the ones of lazyarray_, WeldNumpy_ and PyLops_ libraries,
+which, to the best of our knowledge, primarily provide compact descriptions of
+arrays which entries can be evaluated efficiently on the fly.
+
+It's worth noting that the way PyLops_ exhibits SciPy `LinearOperator`_-s
+in its API is different. Indeed, PyLops_ provides Python classes (like Kronecker_)
+while Lazylinop rather provides Python functions in the SciPy style
+(as `kron` ).
+
+.. _LazyTensors: https://www.kernel-operations.io/keops/python/LazyTensor.html
+.. _lazyarray: https://pypi.org/project/lazyarray/
+.. _WeldNumpy: https://www.weld.rs/weldnumpy/
+.. _PyLops: https://pylops.readthedocs.io/en/latest/api/index.html
+.. _SciPy: https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.kron.html
+.. _Kronecker: https://pylops.readthedocs.io/en/stable/api/generated/pylops.Kronecker.html
+.. _KeOps: https://www.kernel-operations.io/keops/index.html
+.. _LinearOperator: https://docs.scipy.org/doc/scipy/reference/generated/
+   scipy.sparse.linalg.LinearOperator.html
+.. _kron: https://faustgrp.gitlabpages.inria.fr/lazylinop/api_lazylinop.html#lazylinop.kron
+
```

## Comparing `lazylinop-1.6.1.dist-info/RECORD` & `lazylinop-1.7.0.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,40 +1,42 @@
-lazylinop/__init__.py,sha256=FbA-Tgg1YqKZV7NVY044TKy0jNSsvuDRC_KJ2ts081U,126
+lazylinop/__init__.py,sha256=PZXhNlLDm4g5O8ZhjFeDnKY2ts-dAjzAh8jI66UOG84,126
 lazylinop/check_op.py,sha256=F9Fruv6a-_izX9E-RqgY369FsSUPJBzNexfa1eCc310,8275
-lazylinop/lazylinop.py,sha256=AeSCK0hE6IXrU3wg3fKk976IpKNvttulnN4o9j60bh8,47849
+lazylinop/lazylinop.py,sha256=l3UbMJNekVw2q2dN_D-z0BVCKlgd6vo06PiA4Q-LVvY,50965
 lazylinop/basicops/__init__.py,sha256=_LNJ-J7w_qkGvBs0OgSWJl5mYwcgBIVc6E5qf4fp2YU,370
-lazylinop/basicops/add.py,sha256=NyYimTpMYuGxBVkPw9DhdxexzGdrRfHkjk4-Gbv_rDU,1373
-lazylinop/basicops/blockdiag.py,sha256=zCqOVOng8-j10pkdfALRHQFlIe4QVMCP_BHlbvgJtmI,2164
-lazylinop/basicops/cat.py,sha256=6R7voYFhbdp5AHce_9t8H0Vbo-CHPQGY0LksqFQI-NY,1851
-lazylinop/basicops/diag.py,sha256=mHUKMdPPNiJmGYFimHhev7oWT3I2t8uOcChbvozezHo,3839
-lazylinop/basicops/eye.py,sha256=rVOB6QwqeUGzmHYcqJsha42kpe7JL1bCD4RLHWOBhWo,3403
-lazylinop/basicops/kron.py,sha256=4ZoLPPQ3P_jv0uSEe3oUctFr2lunBO2Z34XiR-3wxl0,3550
-lazylinop/basicops/ones.py,sha256=9IqRs9FYKG_eu1k-wgwVzUCZHD4qzB9R2BQVUagxVD4,2309
-lazylinop/basicops/pad.py,sha256=qGrlwTCPpWoOf5WhbYTan1xGfjcbAjGotRD-G2OjUX4,29888
-lazylinop/basicops/zeros.py,sha256=ndsv-_SE3D79mHxxV0AAiMJi8sTSCiKEK2VFD48mJKU,1580
-lazylinop/wip/__init__.py,sha256=SSJR9p7CuzmveNtmI8Smf_P7NwcCHVlaJ9PUULxaBHQ,201
+lazylinop/basicops/add.py,sha256=PVftHIYd4l5Ddhr_kSoZCzcpPza14ylL0u4-62gYW3M,1508
+lazylinop/basicops/blockdiag.py,sha256=Ka2zsHzFNSoyDQC3VVMVsL_xHriY4QWg53Bf6zZeSKw,2255
+lazylinop/basicops/cat.py,sha256=8anT601uU8owwDD1LrxNN4mEVyBzSRqLdY_5IgBns_I,1852
+lazylinop/basicops/diag.py,sha256=I3Ai0tT5SFfM9mg33oirV4P5LeNgBN3eAawn6kH6rNE,11699
+lazylinop/basicops/eye.py,sha256=lWppYxMOhXUxKHUL3oS086GTXW2Zqn87GRESzwEy7ec,3406
+lazylinop/basicops/kron.py,sha256=Tz9tFkXqZ95F4IWdMIlVrN-vVuIi3mkf4A2TjfBuunQ,3792
+lazylinop/basicops/ones.py,sha256=W3cH6TY4uyc0ZORGut9xfWJY924WSFkZJX-TIKb5mTg,2309
+lazylinop/basicops/pad.py,sha256=ryon701dqmAntpa8nyHT8DsYqhsnv6NV3vzj2U1oDbo,31288
+lazylinop/basicops/zeros.py,sha256=tLcN6ohWz51r5iwVtWYFDWCambR0txymC_18og9-B9s,1573
+lazylinop/wip/__init__.py,sha256=ww8T00bJlNfAZtvPfJOCIqfNmsg9PomHmWyhu2kB3QM,78
 lazylinop/wip/code_optimization.py,sha256=ieJcsn0RFt8E3FBwv6zH2bddRkEDiupp0nsnYDLr__U,1443
 lazylinop/wip/linear_algebra.py,sha256=KuUz7eyOxNn3PlymsQ_h5l1qCmLUfbSoCI5ZbwIFYfw,1447
-lazylinop/wip/polynomial.py,sha256=XW6qFrutVPSVj2ev3xPa0uNYkxO9tnVagwWO2U_5AWY,43982
+lazylinop/wip/polynomial.py,sha256=YZ0KTdHaspNw1fuvjNsFjgWtfLGlAXF-nEqAJjE8TQA,68835
 lazylinop/wip/signal.py,sha256=0hIj2rb5xJ85ehZ-y4xcr3MumYJBsaEum-QV38SG6Fo,133585
 lazylinop/wip/special_matrices.py,sha256=bU0UPHN4VbvpKEes7FQSJi5FnBPpzMlyQxKmt6nNWi0,57938
 lazylinop/wip/linalg/__init__.py,sha256=tT37IW-J-jlBQzHhIWeCZLyqypFOra8B7t3Tlz3fCTA,298
 lazylinop/wip/linalg/coshm.py,sha256=81UlRLwlaeYT6vjIQjsG41MRHp56P8GuDaHWrdgYtAY,4792
-lazylinop/wip/linalg/cosm.py,sha256=3ScjW2krH4cikryYhv7dPpVeqojYeg3Ij-jMH1e4-CU,2880
-lazylinop/wip/linalg/expm.py,sha256=_0qJAIbKsoDnpgdn6qbnq6BCLmzR39paf-3JAr4TvH8,4297
+lazylinop/wip/linalg/cosm.py,sha256=MWsI6i8ks4VHSXbBE5Jl4DXZm7kMfVKv-BelOF0CKtU,2820
+lazylinop/wip/linalg/expm.py,sha256=KZph2urO9i6eGfsMgv8WS4jdmn2DutN2khiG8sRUTOc,4237
 lazylinop/wip/linalg/khatri_rao.py,sha256=ob4rPDzX2WU4DTZz-02mdcJaaQTBwpS3Koldaxofozw,5587
 lazylinop/wip/linalg/logm.py,sha256=JJDAiqOeWN7fBY_6Ju04Qn1tIN0hLqKVpG4luWKP3bM,4667
 lazylinop/wip/linalg/sinhm.py,sha256=qdr8snq2n5AzbOpHhThHFbjivdZXCp34oBrR1p9dxFc,4694
-lazylinop/wip/linalg/sinm.py,sha256=YEZ-PYKIYXlIAkVGN59ZdrRvl8VABYpstysPeag7ctc,2887
+lazylinop/wip/linalg/sinm.py,sha256=zMPBAHomz4YFWIA2ZWDyWQWvV82ermLiYJ_hUqned-c,2827
 lazylinop/wip/linalg/spectral_norm.py,sha256=oJi89eZA3yzzeIpE5f1AyDmvkQ2QXLC-G3Lw7oOoHfQ,1582
 lazylinop/wip/linalg/sqrtm.py,sha256=NCC-rQdNwOScIawgTYGHiRPRTA54O2t1sBZ6i2rRXiI,3754
 lazylinop/wip/parallel/__init__.py,sha256=iuAy8qIWtIv67Ro5GkkFUUaJUyJOuYXhkCaF0k8fFAo,253
-lazylinop/wip/parallel/mpilop.py,sha256=LhAH07idIamBLzfw6oWiYuy5gDXBedUtNAq-F6_306c,8324
+lazylinop/wip/parallel/mpilop.py,sha256=zJQXwVoQIOiL1bHbg_wNgqMKq4DH45LVayRxq-wp-rA,8328
 lazylinop/wip/parallel/pmatmat.py,sha256=2stXEbqFsj984Eg47EPbMtAutQFb9shSTtJHVQPefKw,4897
 lazylinop/wip/parallel/pmatmat_mpi.py,sha256=9s6o8dfWQitLlZSa5MVdkzke6JM7606d_i88a7aVMGo,4250
 lazylinop/wip/parallel/pmatmat_process.py,sha256=pTUXpSB0vq4KGNepKH3uQkmN8fkF6KFEuTWcLUwt-p0,5902
 lazylinop/wip/parallel/pmatmat_thread.py,sha256=gzjIoNV-ePz30K0l_TipJi--VyVfO3vl0E8oOn9OH5o,3306
-lazylinop-1.6.1.dist-info/LICENSE.txt,sha256=jHt8qQXwxwsxIgSCZbFwPqQw3R1QWQK0JzZZ3PAwlU0,1434
-lazylinop-1.6.1.dist-info/METADATA,sha256=XHbaSXuro0couZiLu05-AV-pQQ69c_NYMBxARbsIGMc,5700
-lazylinop-1.6.1.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
-lazylinop-1.6.1.dist-info/top_level.txt,sha256=zq6N2WH1Vl_0zSzqC12W0Oil87_uMjD3sYhWGjRioIc,10
-lazylinop-1.6.1.dist-info/RECORD,,
+lazylinop/wip/random/__init__.py,sha256=Sqc6D6d_4UI8LQTlBzRz5IDpSLVK5ejcL5FJmC_A2FI,23
+lazylinop/wip/random/rand.py,sha256=8ZEtNxJtInOsJxcYDj8JdTobNzLXlaEmCDAlqbMq_mo,6721
+lazylinop-1.7.0.dist-info/LICENSE.txt,sha256=jHt8qQXwxwsxIgSCZbFwPqQw3R1QWQK0JzZZ3PAwlU0,1434
+lazylinop-1.7.0.dist-info/METADATA,sha256=0tDXTCFWvW-2-nhzbcyUzNGlgCkDlDtEsaYKQhoInY8,8199
+lazylinop-1.7.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+lazylinop-1.7.0.dist-info/top_level.txt,sha256=zq6N2WH1Vl_0zSzqC12W0Oil87_uMjD3sYhWGjRioIc,10
+lazylinop-1.7.0.dist-info/RECORD,,
```

